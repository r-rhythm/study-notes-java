# 概述
`java.util.concurrent` Java 并发编程包

## 可重入锁
指的是一个线程获得锁之后,在调用本类中其他需要锁的方法时,也可以正常获得锁,在底层上的表现就是 AQS 类中的 states 的值,每次重入都 +1

# 多线程回顾
进程
线程
并行
并发
[[多线程#Java 程序中 wait/sleep 什么区别?|Java 程序中 wait/sleep 的区别]]
[[多线程#开启新线程的方式]]
使用 Lambda 表达式简化开发

## 多线程编程模板
1. 创建资源类
2. 资源类中按照需求提供同步(synchronized)方法
3. 创建线程对象,调用资源类方法


## 实现 synchronized 同步锁的三种形式
测试详见 synchronized 八锁问题
1. 对于普通同步方法,锁持有当前的对象(this)
2. 对于静态同步方法,锁持有当前类的 Class 对象
3. 对于同步代码块,锁持有Synchronized()括号内配置的对象

# ReentrantLock
## 可重入性
> ReentrantLock & synchronized 都是可重入锁

在一个 synchronized 修饰的方法或代码块中调用本类其他的 synchronized 修饰的方法或代码块时是永远可以得到锁的,不会产生死锁.

## 公平性
> 公平锁指的是各个线程间按照申请锁的顺序来获取锁

ReentrantLock 是一种公平锁,在参数 fair 设置为 true 即可

## 为什么会有公平/非公平锁的设计? 
使用多线程很重要的考量点就是线程切换的开销,使用非公平锁能够更加充分的利用 CPU 的时间片,尽量减少 CPU 空闲的状态事件

## 限时等待
ReentrantLock.tryLock(),尝试等待锁,如果超时没有等到则返回 false,可以用于解决死锁问题

## ReentrantLock 和 synchronized 的区别
synchronized 加锁与释放锁的过程是程序自动的
ReentrantLock 的获取锁和释放锁需要手动实现,他会更加灵活,也更加繁琐

# 读写锁 ReadWriteLock
允许同一时刻被多个读线程进行访问,但在写数据时阻塞其他所有读写线程
分别使用 readLock 和 writeLock 来为读方法或写方法上锁和释放锁

读写锁的互斥性(同一把读写锁)
- 对于所有的读操作,锁都是共享锁,不互斥
- 只要有一个写操作,则于其他所有操作互斥

## 降级锁
从写锁降级到读锁

# 线程间通信
1. 判断线程调用的方法是否符合条件
2. 如果符合执行业务逻辑,不符合则 wait()
3. 执行完毕后通知其他线程
## 虚假唤醒
线程之间通信,不能使用 if() 来做判断,会产生虚假唤醒,if() 条件只会检查一次,线程被重新唤醒后会从阻塞的地方开始执行.就不会在判断是否符合这个线程的执行条件
使用 while 循环判断,让线程每次被唤醒时都走一遍条件判断,只有符合条件才能执行相关业务逻辑

## 线程通信 Condition
new ReentrantLock().newCondition();
一个 Condition 就相当于绑定了一个锁,每个锁可以有多个条件

## 定制化调用通信
通过属性标志位,可以实现多线程间的顺序调用

