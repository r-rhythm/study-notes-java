# 为什么用线程池?
1. 提前准备好一些线程资源, 如果某个业务方法中需要使用多线程即可直接在线程池中获取, 用完后再放回线程池以做到**线程复用**
2. 当任务达到后, 不需要等待线程创建即可立即执行, 提高项目的响应速度
3. 方便对线程进行统一管理和分配, 监控线程的状态

# 线程池的创建方式

## Executors 工具类

### 创建方式
1. 使用工具类创建对应线程数的线程池
2. `Executors.submit()` 提交任务到线程池, 可以传入 Callable & Runable, 可视情况而传入 [[02_JUC辅助工具类#Callable 和 Runable 有什么区别?]]
3. 手动关闭线程池

### Executors 创建线程池的三大方法
1. 单池单线程
2. 单池指定数量线程
3. 单池自适应 (可扩容) 线程

### 为什么不允许使用 Executors 创建线程池
1. 一池一线程/指定数量线程池调用的底层方法的队列长度为 `Integer.MAX_VALUE` 21 亿, 如果任务非常多, 大量任务都会阻塞排队, 存在 OOM 风险
2. 可扩容的线程池创建方法允许创建 `Integer.MAX_VALUE` 21 亿个线程, 存在 OOM 风险
3. 线程池不允许使用 Executors 去创建，而要通过 ThreadPoolExecutor 方式, 创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。

## 自定义线程池
1. 直接创建 ThreadExecutor 对象, 根据自己的业务场景创建符合要去的线程池
2. 传入合适的线程池参数即可创建线程池

# 自定义线程池的创建方式

## 创建线程池的七大核心参数
使用三大方法创建的线程池最终都调用了 `ThreadPoolExecutor(...)` 构造, 这个构造有**七大核心参数**
1. CorePoolSize 常驻的核心线程数量
2. MaximumPoolSize 最大执行线程数
3. KeepAliveTime 空闲线程的最大存活时间 (不包含核心线程数)
4. TimeUnit 最大存活时间的时间单位
5. ArrayBlockingQueue 任务队列, 存放还未被执行的任务
6. ThreadFactory 指定创建线程池的工厂
7. RejectedExecutionHandler 任务饱和后拒绝策略

## 如何合理设置线程最大线程数和核心线程数?
- 核心线程数应与最大线程数一致, 类似于 [[Java Virtual Machine]] 中的初始化内存与最大内存
- 数值的设置应结合项目业务场景
    - CPU 密集型: 要处理大量用户请求, 需要占用大量 CPU 资源的情况, 设置为服务器本身核心数量 (逻辑核数), 原因类似于 [[Nginx#Nginx 细节补充]]中的 worker 数量设置
    - IO 密集型: 固定的计算需求, 需要占用大量 IO 资源, 文件/数据库 IO
    - 建议使用变量 `Runtime.getRuntime().availableProcessors` 获取当前运行环境的核心数进行设置

## 四种拒绝策略
1. AbortPolicy (默认) 拒绝执行策略: 抛出 `RejectedExecutionException` 异常并拒绝执行新任务
2. DiscardPolicy 丢弃策略: 默默丢弃无法处理的任务, 不予任何处理也不抛出异常
3. DiscardOldestPolicy 丢弃最早任务策略: 抛弃队列中等待最久的任务, 再尝试重新提交当前任务
4. CallerRunsPolicy 超过处理上限的任务会分配给调用者线程处理

# 线程池工作原理
![[JUC-线程池工作原理.svg]]
1. 在创建线程池后, 线程池中的线程数量为 0
2. 在提交一个任务后, 线程池会做出一下判断
	1. 如果正在运行的线程数量小于设定的常驻核心线程数, 那么会立即创建新线程执行这个任务
	2. 如果正在运行的数量已经达到设定的常驻核心线程数, 将任务放入任务队列中
	3. 如果任务队列已满且正在运行的线程数小于设定的最大线程执行数, 那么创建**非核心线程**立刻执行这个任务
	4. 如果队列已满且正在运行的线程数已经达到设定的最大线程执行数, 则以任务饱和后拒绝策略来执行
5. 当一个线程执行完任务后, 会从队列中取下一个任务来执行
6. 当一个线程无事可做超过空闲线程最大存活时间 keepAliveTime, 线程会判断当前线程数是否大于常驻核心线程数 corePoolSize, 如果是, 那么这个线程会被停掉. 所以线程池在完成所有任务后, 最终都会收缩至 corePoolSize 大小


# Java 内存模型 (Java Memory Model)
它是保证多线程高并发的底层原理

## 作用
- 它是一种抽象的规范 (模型), 为了屏蔽不同系统和硬件对于内存访问逻辑的差异, 让一套代码在不同的平台下达到相同的内存访问效果
- 用于解决相同代码在不同系统运行时因为不同系统的原因导致的各种问题

## 相关概念
1. 主内存: 保存所有变量 (对应物理内存)
2. 工作内存: 不同线程独享的内存, 保存线程用到的变量副本, 负责与线程/内存交互 (对应寄存器&高速缓存)

## JMM 中的约定
1. 线程加锁前: 必须将共享变量的最新值刷新到工作内存中
2. 线程解锁前: 必须立刻将共享的的变量从工作内存刷新到主内存中 (刷新共享的变量值)

## 内存模型的三大特性
1. 原子性: 即一组操作不可中断, 即使是多个线程一起执行, 一个操作一旦开始就不会被其他线程所打断
2. 可见性: 是指一个线程修改了一个共享的变量后其他线程能够立即知道这个修改
3. 有序性: 对于一个程序而言, 执行的顺序并非是从前往后依次执行的, 可能在执行的途中会产生不影响语义的指令重排, 重排后的指令与原指令顺序未必一致

# Volatile 关键字

## 简介
`volatile` 是 Java 提供的一种**轻量化的同步机制**. 相较于 `synchronized` 同步代码块, `volatile` 不会引起线程上下文切换和调度, 进而保证更低的系统开销

## 内存中的可见性
- ~~修改 volatile 修饰的变量时, JMM 会把工作内存的中的值立即刷新到主内存中并发出通知~~
- 当 volatile 关键字修饰的变量被某个线程所修改后, 会立即将这次的修改刷新到主内存中, 随后通过 **CPU 总线嗅探机制**通知其他线程
- 当线程收到通知后, JMM 会将该线程对应的本地内存设置为无效, 必须重新回到主内存中读取最新的共享变量
- 所以**对于 volatile 变量的写是直接刷新到主内存中, 读是直接从主内存中读取**

> 在 [[02_JUC辅助工具类#CopyOnWrite 写时复制容器]]中, 都是最终存储数据的数值变量都是使用 volatile 关键字来修饰的, 保证了在多线程修改的情况下保证其可见性 (被一个线程修改后能被其他线程立即查看)

## 有序性
指令重排: 指我们编写的代码计算机可能并不会按照编写的顺序执行, 这就称为指令重排. 从 `源码 -> 字节码 -> 机器码指令 -> 内存系统` 的执行过程中都可能发生指令重排

Volatile 关键字通过内存屏障禁重排

## 通过内存屏障保证有序性及可见性
一种屏障指令, 使 CPU 或编译器对屏障指令前和后发生的内存操作做一定的约束. 内存屏障指令能够保证所有的 CPU 操作都直接刷新到主内存中
Volatile 通过内存屏障来确保有序性和可见性

读屏障: 在读指令前插入读屏障, 使工作内存或 CPU 告诉缓存中的数据失效, 重新回主内存中获取数据
写屏障: 在写指令后插入写屏障, 强制把工作内存和缓冲区的数据刷新到主内存中

## Volatile 与 synchronized 的区别
> `synchronized` 是解决**执行控制**的问题, 它能够阻止其他线程获取当前对象的监视器 (锁) `Monitor`, 这就使得被 `synchronized` 保护的代码块无法被其他线程锁访问, 也就是无法并发执行. 同时, `synchronized` 还会创建一个内存屏障, 这个内存屏障将所有 CPU 操作的结果都刷新到主内存中, 从而保证操作的内存可见性以及操作的原子性
> `volatile` 是解决内存可见性问题, 所有对 `volatile` 变量的修改都会直接刷新到主内存中, 保证了变量的可见性

`volatile` 与 `synchronized` 的主要区别有:
1. 作用范围不同: `volatile` 只能修饰变量, `synchronized` 能够修饰类、方法、变量、代码块
2. 对线程响应不同: `volatile` 不会阻塞线程, `synchronized` 可能会造成线程的阻塞
3. 指令执行顺序可能不同: `volatile` 关键字修饰的变量不会发生指令重排, `synchronized` 标记的内容可能被编译器所优化
4. 对线程安全处理不同: `volatile` 只能保证内存可见性, 并不保证原子性, `synchronized` 能够保证内存可见性的同时保证操作的原子性
5. 本质上不同: 使用 `volatile` 关键字本质上是告诉 JVM 此变量在工作内存中的值不是确定的, 需要从主内存中获取, 而使用 `synchronized` 则是锁定当前变量, 只有当前的线程能够访问该变量, 在此线程释放锁以前, 其他线程都将被阻塞住



# CAS
Compare and Swap 比较并替换 (修改), 通常用于数据的更新, 能够做到保证性能的情况下对共享变量进行线程安全的修改
> [!info] 
> CAS 是解决并发安全问题的一种乐观锁算法, 它操作三个基本参数: 内存地址/旧值/新值.
> 
> 它的核心类 Unsafe 直接操作底层硬件进行更新, 会根据拿到的内存地址获取旧值, 并将他与用户提交的旧值进行对比, 如果相等则将其内容替换为用户传入的新值, 如果不等则更新失败... 类似于更新密码的过程
> 
> 更新失败后会重复执行, 重新从内存中获取更新后的值, 直至更新完毕 (自旋锁)

它只保证某个变量的原子性, 不保证代码块的原子性


# AQS (AbstractQueueSynchronizer 抽象队列同步器)

## 简介
AQS 是 Java 并发编程的基石, JUC 的底层基础框架, 主要解决了**锁分配给谁**的问题

通过一个 FIFO 队列来完成线程对于资源类获取的排队工作, 通过一个 int state 来表示锁的持有状态 (锁是否被占用), 通过 CAS 完成对 state 值的修改


## 源码分析
ReentrantLock/Semaphore/.... 的 JUC 并发编程包内的锁实现大都通过 AQS 来完成, 以 ReentrantLock 为例


ReetrantLock 源码中包含了 Sync/NonfairSync/FairSync

ReentrantLock 源码解析:
1. Lock: sync. Lock () 只要调用了这个方法, 必然会获取锁超过, 如果锁被线程锁持有, 就自旋获取
2. Sync. Lock () 加锁的实现在 NonfairSync & FairSync 中
3. 在 NonfairSync or FairSync 加锁实现内, 通过 ==CAS== 去更新锁的状态, 如果更新成功, 获得锁后设置当前锁的持有者 `setExclusiveOwnerThread()` , 如果更新失败, 调用 `acquire(1)` 方法
4. `tryAcquire(arg)` 尝试 arg 次获取锁, 如果再失败休眠当前线程, 等待其他线程唤醒
