# 存储购物车
1. 购物车信息在 redis 中使用 [[Redis#Redis 中的数据类型]] hash 结构进行存储, userId 作为 key, skuId 作为 field, pojo 数据作为 value
2. 临时用户 id 何时生成? 在未登录的情况下, 首次添加商品到购物车时前端生成并存储到 cookie 中, 在请求后台接口时会将这个 tempUserId 放入携带到请求头, 由我们在 gateway 网关的过滤器中获取

# 添加购物车
补充:
- 单个商品最多存储数量为 200

流程:
1. 用户点击购物车按钮
2. 获取 userId 或 tempUserId
3. 从 redis 中获取用户的购物车信息
4. 判断此次用户想要添加的商品在购物车内是否已经存在
5. 如果存在, 则更新这个商品的数量/实时价格/最后更新时间, 其中商品数量最大值为 200; 如果不存在则封装商品数据存入 redis 用户购物车中

# 合并购物车

流程:
1. 获取 userId 和 tempUserId
2. 通过 tempUserId 获取用户在未登录情况下的购物车信息
3. 通过 userId 是否为空来判断当前用户是否登录, 如果未登录则将购物车数据排序后返回
4. 如果 userId 存在, 则合并购物车

合并购物车流程:
1. 通过 userId 在 redis 中获取当前登录用户的购物车信息
2. 如果 userTempId 下的购物车数据不为空, 判断对应的 sku_id 在已登录购物车中是否已经存在
	1. 如果存在, 则在 userId 下的购物车数据中数量相加 *最大值 200*
	2. 不存在, 将未登录的商品信息添加到购物车中
3. 将未登录时的购物车数据合并到当前 userId 下的购物车中并更新时间, 实时价格, 选中状态等信息
5. 合并购物车结束, 从 redis 中移除未登录状态下的购物车数据
6. 将购物车数据排序返回

# 订单

## 结算页面接口数据
- 用户收获地址信息
- 订单总数量
- 订单总金额
- 流水号 (隐藏)
- 商品详细订单 (redis 购物车中状态为已选中的商品数据)

## 流水号的作用 (如何防止重复表单提交?)
每次点击去结算后都会生成一个唯一的流水号, 在结算时只有流水号相等才继续结算, 否则就认为是表单的重复提交. 也类似于保证幂等性的操作 [[消息队列 Message Queue#消息幂等性保障]]

## 提交订单
1. 校验流水号, 如果流水号不相等则证明是用户重复提交表单, 不执行订单结算返回错误信息
2. 核对商品库存及价格, 如果商品价格有变动或者库存不足则抛出异常
3. 提交订单, 设置相关信息
	1. 设置订单支付状态为 UNPAID 未支付
	2. 更新订单表 order_info : 订单号, 用户 id, 总金额, 订单状态, 订单交易编号 out_trade_no
	3. 订单商品详情表 order_detail : 订单 id,sku_id, 商品价格及其他信息
	4. 添加订单描述
	5. 设置订单过期时间, 24 小时未支付则取消订单
	6. 从购物车中删除已生成订单的商品
7. 从 redis 中删除流水号, 防止重复提交
7. 返回订单 id 

## 关单
关单业务逻辑
1. 判断订单是否为未支付, 只有未支付的订单才继续处理
2. 判断支付信息表 payment_info (支付环节存入的信息) 中是否有支付信息记录, 如果没有则直接取消订单
3. 如果支付信息表中有数据则判断支付状态是否为未支付, 如果是则调用支付宝接口查询是否存在此订单 (可能出现扫码后未支付)
4. 关单后设置 orderInfo 表的状态为已取消
5. 确认消息已接收

==采用延迟消息关单==
[[RabbitMQ#延迟队列]], 此项目中使用延迟插件的方式进行业务处理
补充了 [[RabbitMQ#死信队列和延迟插件的区别]]


# 支付
[[day16_支付宝支付]]

支付接口
1. 判断订单是否已经关闭或已经支付, 二者有其一都直接返回失败
2. 在支付消息表记录 payment_info 支付消息
3. 封装请求支付宝接口时必填的参数信息 (包括同步回调与异步回调地址)
4. 调用支付宝支付接口


同步回调
- 在支付成功后, 支付宝页面会定时跳转到我们配置的同步回调地址, 这个接口会重定向到我们自己的支付成功页面

异步回调
- [[day16_支付宝支付#异步通知]]
- 使用 alipay 的 sdk 验签及校验回传参数及是否产生自本系统 (对账)
- 使用 redis 的 setnx 来解决重复回调的问题, 如果之前已经回调过了则不再处理[[消息队列 Message Queue#消息幂等性保障|幂等性校验]]
- 判断订单是否支付成功, 如果支付成功, 修改 payment_info 表中的交易编号 ==trade_no== (支付宝异步回调时传入) 及支付状态为 PAID ; 如果在处理业务途中出现故障, 需要将 redis 中的 setnx 的值移除以便下次回调时继续处理
- 通过 mq 发送消息, 由 service-order 订单服务消费消息更新订单表的支付消息及扣减库存


# 退款
1. 通过远程调用获得订单的消息 orderInfo
2. 订单如果已经关闭则不再处理
3. 封装交易编号 (或第三方交易订单号皆可) 及退款金额
4. 获取一个 `AlipayTradeRefundRequest()` 对象实例, 通过这个实例来封装数据
5. 请求支付宝退款接口, `FundChange` 返回 Y 即为退款成功

# 支付宝相关面试题

支付宝接口传了哪些参数?
1. 总金额
2. 第三方交易编号 out_trade_no
3. 订单标题
4. 产品码 product_code

公共参数有哪些?
1. Appid
2. Secrete_key
3. 同步回调地址
4. 异步回调地址
5. 支付成功地址


# 秒杀
[[day18_秒杀]]

## 数据预热准备
1. 后台添加参与秒杀的商品后, 审核商品信息添加至秒杀商品数据表中 seckill_goods
2. 设置定时任务, 在每天凌晨并发量小时发送消息, 将商品提前存入 redis 中
	1. 消费者从 seckill_goods 表中查询出当天参加秒杀获得的商品
	2. Redis 中商品信息以 hash 结构存入 `key: 常量 field:sku_id value:商品信息`
	3. 商品库存则是通过循环参加活动的商品数量的方式, 使用 list 结构存入
4. 使用 [[Redis#Redis 发布订阅模式]] , 如果 redis 中 list 的 value 已经为空, 则将状态位修改为 0
5. 使用发布订阅的原因是: 状态位值是存储在 jvm 中的, 它是一个 cacheMap 类中的静态常量, 但是在微服务架构下, 会有多个 jvm, 如果不使用发布订阅模式则不能在多个服务中同步更改商品的状态位
6. 为什么要使用 `jvm+发布订阅模式` 存储状态位数据? 从 jvm 堆中获取的速度比 redis 更快 (redis 需要通过网络传输), 为了保证秒杀系统的极致性能, 选择这种方式来做实现

## 展示秒杀商品列表
从 redis 中直接获取即可

## 展示秒杀商品详情
根据 sku_id 从 redis 中获取数据

## 生成抢购码
抢购码的作用在于只有从秒杀界面点击的请求才会被处理, 否则不做处理
使用 MD5 加密 userId 来生成抢购码

## 预下单
1. 用户点击抢购后, 做一系列验证 (状态位间接校验库存/抢购码)
2. 发送消息到真正下单的接口

## 真正下单
1. 校验秒杀状态位
2. 使用幂等性来判断用户是否购买过
3. 使用 list 的 rightPop 弹出来扣减库存
4. 将用户与商品信息保存到 redis 中, 以便下次通过幂等性来判断同一个用户只能秒杀一次
5. 使用 mq 发送消息, 生成订单信息及扣减库存
6. 用户付款前往付款页面, 秒杀服务结束...
7. 活动结束, 清除 redis 数据

## 处理三大限制的手段
- 库存限制: 使用 redis 中的 list 结构来存储库存数据, 配合发布订阅模式+jvm 静态变量存储状态位来解决
- 购买时间限制: 前端购买按钮限制+后端抢购码的形式
- 购买数量限制: 使用 redis 的幂等性来保证相同的用户活动期间只能购买一次
