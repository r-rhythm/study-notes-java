# 当我学 JVM 我学些什么
- 学习 JVM 能够让我们理解程序运行的底层原理, 知其然知其所以然
- JVM 也是 Java 开发面试中极为高频的一个方面
- 学习 JVM 可以解决实际工作中的内存溢出问题
# 常见问题
## 垃圾回收是否涉及栈内存？
 不涉及，因为栈内存在方法调用结束后都会自动弹出栈。
 
## 方法内的局部变量是线程安全的吗？
方法内的局部变量只要没有使用 static 修饰就是安全的, 因为每个线程对应一个栈, 每调用一个新的方法都产生一个栈帧, 栈帧的局部变量都是私有的
- 每个栈默认容量为 1M
## 什么常见下会出现 OOM
栈区
- 递归调用, 没有设置停止条件或条件设置不合理导致栈溢出

堆区
- 调用 findAll () 方法查询全部数据时, 如果全部数据过大于堆内存且 GC 也没有空间可回收时就会出现 OOM
- 在使用 POI 时, 它会将 Excel 报表直接装在内存中进行解析, 如果报表大小超过了堆可用内存, 且 GC 也没有空间可回收时就会出现 OOM

元空间
- 内存大小设置被合理或内存不足
- 元空间使用的是物理内存

程序寄存器是唯一一个不会发生 OOM 的区域
## 如何理解 JVM
- JVM 的内存结构维度 (==元空间, 堆==, Java 栈, PC 寄存器)
- 类加载器维度 (类加载的阶段)
## JVM 常用的调优参数有哪些?
- 正常堆的初**始化内存大小与最大内存大小设置为同样大小**, 尽量减小内存波动
- -Xms (memory start) 初始堆的内存大小, 默认是物理内存的 1/64
- -Xmx (memory max) 最大堆内存大小, 默认是内存的 1/4
- -XX:+PrintGCDetails 输出详细的 GC 处理器日志
- -Xss (stack size) 栈内存大小
- 在统计内存大小时, 幸存者 0 区或 1 区只会统计一个区域, 因为在实际使用时他们只会有一个区域被使用

## JVM 调优的目的是什么?
JVM 调优就是尽量减小 GC 的频率和 FullGC 的次数, 因为 JVM 在 GC 调用的过程或将用户线程暂时挂起 (Stop the world), 尽量提升用户代码的执行时间 (保证吞吐量)

# JVM 简介
- 它是 Java 程序的实际运行环境, 负责解释运行编译后的 . Class 文件
- JVM 是 Java 程序运行的基石, 通过 JVM 实现 Java 程序的 "Compile once, run anywhere"
- JVM 运行在操作系统之上, 与硬件没有直接交互

# JVM 结构组成
![[JVM-内存结构.png]]
1. 类装载器子系统中的一系列类加载器加载 . Clss 文件
2. 类的一些基础 (模板) 信息被存放在**方法区**(jdk8 以前称为永久代, 8 以后称为元空间), [[反射 Reflection]] 就是从这个空间中获得这个类所包含的所有信息
3. 堆用于存放实例, 几乎所有的对象都在堆中分配内存, 它存放着对象的实例, 数组等
4. JVM 虚拟机栈, 方法调用时方法的参数等占用的空间
5. 本地方法栈存储的是虚拟机运行时要使用到的 native (非 Java 语言所编写的代码) 方法, 通过**调用本地方法接口, 调用 C & C++ 的本地方法库**
6. 程序计数器用于记录当前线程执行字节码文件命令的行数 

# 类加载器 ClassLoader

## 介绍
类加载器是 Java 虚拟机中的一种机制, 负责加载类的二进制代码 (.class 文件) 到内存中
- 负责加载 class 文件, 所有标准的 class 文件开头都有特别标识 `ca fe ba be`
- 它只负责 class 文件的加载, 并将加载后的内容存入方法区 (元空间), 至于它是否可以运行则是由执行引擎决定的

## 相关工具 & 指令
- 使用 javap -v class 命令对 . Class 文件反汇编, 获得这个文件存放在元空间 (方法区) 的类初始信息
- 使用 jps 指令查询所有本机上正在运行的进程
- 使用 HSDB

## 类的加载过程

### 概览
类的加载过程可以粗略的分为三大步:
1. 加载: 就是将类的二进制代码从存储媒介 (磁盘、网络) 中读取到内存中的过程, 在这个过程中, 也有其他任务: 比如为类创建一个 Java 对象来表示该类 (Class 类)
2. 连接: 是指将已经被编译的类的二进制代码合并到虚拟机的过程, 他又有三个阶段: 验证、准备及解析
3. 初始化: 是指执行类的初始化方法 `<clinit>` 的过程, 类的初始化方法只会被执行依次, 即使多次通过 `new` 来获得对象实例, 也不会再次执行类的初始化方法
4. [参见: 详解Java类加载过程](https://anye3210.github.io/2021/08/02/%E8%AF%A6%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/)

### 加载
- 通过类的全限定名获取定义此类的二进制字节流
- 将这个字节流代表的静态存储结构转换为方法区运行时的数据结构
- 将类信息、静态变量、字节码、常量等 `.class` 文件的内容放入方法区中
- 在内存中生成一个**代表这个类的 `java.lang.Class` 对象**, 作为方法区的这个类所有数据的访问入口
- Hotspot 采用懒加载机制: 即类只有在被使用到的时候才会被加载

### 连接
- 验证: 确保 class 字节流信息是否符合当前虚拟机的要求, 且不会危害虚拟机滋生的安全
	- 是否以 `(ca fe ba be)` 魔数打头
	- 超类是否为 Object
- 准备
	- 为静态变量分配内存并设置初始值
	- 实例变量只有在创建对象时才会完成赋值
	- `final` 修饰的常量会在编译时就直接赋值
- 解析: 将符号引用替换为直接引用
	- 符号引用: 指向没有实例化的类
	- 直接引用: 指向实例的指针, 这个类在内存中必然已经有了实例

### 初始化
- 调用类的静态代码块完成类的初始化
	- 为静态变量完成赋值
	- 这个静态代码块并非静态方法, 而是 JVM 中初始化类时工作的区域
	- 所有使用 static 关键字修饰的值在 class 文件中都统一放在静态代码块中, 他们的加载顺序按照代码的顺序排列
- 调用 clinit 方法 (JVM 虚拟机)

## 类加载器的分类

1. 引导类加载器 (BootStrap ClassLoader)
	- 通过 C & C++ 编写的本地方法实现, 不是 Java 类
	- 用与加载 Java 的核心类库, 提供 JVM 自身运行时所需的类, 负责加载 `JAVAHOME/jre/lib/rt.jar` 包下的 Java 运行时环境
2. 扩展类加载器 (Extension ClassLoader)
	- 负责加载 `$JAVA_HOME/jre/lib/ext` 中的类和 jar 包, 父类为 BootStrap
3. 系统类加载器 (Application ClassLoader)
	- 加载用户类路劲 classpath 下的类及 jar 包, 也是程序中默认的类加载器, 一般来说, Java 应用的类都是由它来完成加载

此外, Java 还允许通过反射 API 来自定义类加载器

## 双亲委派机制

### 简介
> [!info] 双亲委派模型
> 类加载器在接收到类加载请求时, 并不会直接加载这个类, 而是将这个加载的请求委派给父类加载器去处理, 当父类加载器返回无法加载这个类的信息时, 这个子类加载器才会尝试自己去加载, 这个过程就是双亲委派机制
> 双亲委派模型的优点是可以确保 JVM 中已经被加载过的类不会被重复加载, 同时也能确保 JVM 中的核心类能够得到保护

### 为什么要采用双亲委派机制
- 这样做的好处是, 避免内存中出现多份同样的字节码文件, 也称作**沙箱安全机制**
- 即使在我们私自在 classpath 中定义了 `java.lang.String` 类型, 也是无法将原本的 String 类型覆盖掉的, 因为当这个加载请求传递到 BootStrap 的时候他会自动去加载 `rt.jar` 包下的 String 类, 从而保证了 Java 核心运行环境不受外界的影响. 所以说双亲委派机制保证了安全性

# 执行引擎
负责解释命令, 并提交操作系统执行

# PC 寄存器
- 每个**线程私有的程序计数器**, 一个非常小的内存空间, 用于记录行号
- 它实际上就是一个指针, 指向方法区中即将要执行的代码
- CPU 需要不停的切换各个线程, 在它切换回来后就得知道这个线程该从哪里开始继续执行, PC 寄存器的值就是明确的指定了该执行那一条命令

# 方法区 & 永久代 & 元空间
- 方法区是 JVM 规范中定义的一块内存, 这块内存用来存放类的模板消息 (元信息)
- 永久代 (Permanent Generation) 是 Hotspot 在 jdk1.8 前的实现
- 在 jdk1.8 后的实现称为元空间 (MataSpace)
- 方法区是共享区域

# Java 虚拟机栈

## 简介
- 单个线程运行所需要的内存
- 栈 (栈内存) 是运行时单位, 每个线程私有, 它随着线程创建而创建, 也随着线程的结束而销毁

## 栈帧
- 每个栈由多个**栈帧**(方法调用占用的内存) 组成
- 每个线程只能有一个活动栈帧 (StackFrame), 对应正在执行的方法
- 栈帧中主要保存 3 类数据
	- 本地变量, 方法输入的参数和方法内的变量等
	- 栈操作, 记录出栈/入栈的操作
	- 栈帧的数据, 类文件, 方法等

# 堆

## 简介
- 线程共享
- 一个 JVM 实例只存在一个堆内存
- 几乎所有实例和数组都应该分配到堆上
- 在方法调用结束后, 队中的对象不会马上移除, 仅仅在垃圾回收时才会被移除, 堆空间时 GC 工作的重点区域

## 堆体系概述
- 年轻代 (新生代)
	- Eden 伊甸园
	- From Suivivor 幸存者 0 区
	- To Suivivor 幸存者 1 区
- 老年代

对象大多数都是朝生夕死的, 对于这些生命周期及其短暂的对象, GC 会频繁的进行清理以提高内存的使用效率。而对于一些长期存在的对象 (长期幸存), 例如连接池等, 会将他们存入老年代, 这个区域 GC 不会频繁的进行清理, 以减小系统不必要的压力

所有新创建的对象都会存放在伊甸园, 在经历数次的垃圾回收后依然被引用的对象就会被依次转入幸存者 0 区 -> 幸存者 1 区 -> 老年代

## 年轻代与老年代
![[JVM-堆空间结构.png]]
JVM 虚拟机会根据对象的生命周期时长, 将他们放入年轻代 (Young Generation) 或老年代 (Old Generation)

默认情况下, 年轻代占用堆内存的 1/3, 老年代占用堆内存的 2/3

在年轻代中, 伊甸园与幸存者 0 & 1 的比例为 8:1:1

## 对象在堆中的变迁
赋值 --> 清空 --> 交换
1. 几乎所又对象创建时都会被分配到伊甸园, 当伊甸园内存使用完毕, 但程序又需要 new 新的对象时, GC 就会对伊甸园区进行 **MinorGC**(小范围垃圾回收) , 将伊甸园区不再被其他对象所引用的对象进行回收销毁, 然后将剩余的对象转移到幸存者 From (0 区), 并将他们的年龄 +1
2. 当伊甸园再次触发 GC, GC 会对伊甸园和幸存者 From 区进行垃圾回收, 将没有对象引用的对象销毁, 存活的对象年龄 +1 并移动到 To 区. 幸存者 From 区和 To 区互换, 有一个幸存者区域始终会是空着的 (复制算法)
3. 当对象在多次 GC 过程后依然存活 (默认 15 次, 由 JVM 参数 MaxTenuringThreshold 决定), 就存入老年代
4. 特殊情况, 如果分配的某个新对象占用内存较大, 伊甸园区存放不下的, 会直接存入老年代. 如果老年代的内存不足, 会触发 MajorGC (FullGC)

## 定位分析堆 OOM 问题
1. 安装 **MAT 工具**, 用于查询内存泄漏的工具
2. 尽可能调低堆内存大小, 让问题尽快复现
3. 导出 JVM 的 dump 文件
	1. 在 JVM 运行参数设置 `-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=存储dump的路径` 当出现这个异常, 转储 dump 文件至这个目录
2. 使用 MAT 工具打开 dump 文件, 进行 Histogram 分析, 这个分析可用列出内存中的对象个数及其大小
	1. 深堆 (Retained Heap): 对象本身占用的内存 + 直接或简介引用到的其他所有对象所占用的空间大小
	2. 浅堆 (Shallow Heap): 这个对象本身占用的内存

# GC 垃圾回收

## 垃圾判定
### 引用计数法
给对象中添加一个引用计数器, 每当一个地方引用计数器就 +1, 当引用计数器为 0 时就是没有被引用的状态

由于存在循环引用的情况, 会导致内存泄漏 (未被实际引用的对象也无法被 GC 回收), 例如 a 引用 b, b 再次引用 a, 就始终无法回收这两个对象. 目前这种算法目前已经被大部分 JVM 摒弃

### 可达性分析算法

通过一些列被称为 GC Roots 的对象作为起点, 从这些节点开始向下搜索引用链, 当一个对象没有与任何一个 GC Roots 引用链相连的, 则证明此对象是为可回收对象

所谓 GC Roots 根对象就是一组必须活跃的引用, 在 Java 语言中, 常见的 GC Roots 包括:
1. 虚拟机栈中所引用的对象, 例如线程调用方法的参数, 局部变量等
2. 本地方法栈中所引用到的对象 (native 修饰的本地方法等)
3. 类中静态属性所引用的对象
4. 常量池内的引用, 例如字符串常量池 String Table
6. 所有被 synchronized 锁所持有的对象
7. 基本数据类型对于的 Class 对象, 一些常驻异常对象 (NPE, OOM 等), 系统类加载器

一个对象被标记为垃圾, 至少要标记两次
1. 沿着 GC Roots 标记, 得到可用被清理的对象 (给引用链的对象打标记)
2. 第二次判断可清理对象是否重写 finalized 方法 (finalized 在 jdk9 开始已经被废弃)

### 四种引用情况
- 强引用: 实际开发中最常使用的, 只要引用一直存在, GC 就用于不会回收强引用对象
- 软引用: 在内存不足时, 回收软引用对象
- 弱引用: 对象只能生存到下次垃圾回收前, 在 GC 工作时, 无论内存是否充足都会回收它
- 虚引用: PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 垃圾回收算法
只要 JVM 执行 GC, 就会产生 Stop the world 现象, JVM 调优就是要尽可能的减少垃圾回收的次数

### 标记清除算法 Mark-Sweep
1. 标记: 从 GC Roots 根节点开始遍历, 并标记所有正在被引用的对象
2. 清除: 对堆内存中的所有对象进行遍历, 如果某个对象没有被标记, 则证明它是不可达对象, 可以被回收

问题: 这种方式清理出来的内存空间是不连续的, 产生内存碎片, 还需要额外维护一个空闲列表

### 标记整理算法 Mark-Compact
1. 第一阶段和标记清除一样, 标记所有被引用的对象
2. 第二阶段, 将这些存活的对象整理/压缩 (*Compact 把…紧压在一起或压实*) 到内存的一端, 按顺序排放, 之后清理掉边界外所有的空间

### 复制算法 Copying
- 将内存平均非为两份, 每次只是使用其中一份, 当这部分快满的时候, 将里面存活的对象都复制到另一个区, 剩下的全部清理掉

年轻代中的 MinorGC 就是使用的这种算法, 这也就是为什么 Suivivor To 区永远都是空的原因

特别的: 如果系统中垃圾对象不是很多而有大量存活对象时, 使用复制算法的效率是会很低的。系统需要将这些存活的对象都复制一遍后还得更新栈中的对象引用地址

### 分代收集算法
Hotspot 采用分代收集算法
不的对象生命周期是不一样的, 因此, 为他们分别使用不同的算法能整体提高系统的效率
- 年轻代生命周期短, 存活率较低, 回收频繁, 适合使用复制算法, 以少量对象赋值的成本即可完成快速回收
- 老年代中对象存活率高, 适合采用标记清除或者标记整理算法来进行垃圾回收
