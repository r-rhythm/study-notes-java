# 数据结构/设计模式

## 1. 怎么理解时间复杂度和空间复杂度？
时间复杂度是指算法执行所需要的时间. 空间复杂度则是指算法执行所需要的存储空间

## 2. 数组和链表结构简单对比？
- 数组直接通过下标进行数据查询, 效率更高. 但数组容量达到临界值后, 再添加数据只能进行扩容, 效率更低
- 链表通过存储指针的形式进行数据关联, 这样做的好处是插入及其方便, 只需要存储指针. 但查询效率不及数组
- [[集合#ArrayList/LinkedList/Vector 有什么区别?]]

## 3. 怎么遍历一个树
遍历一个树通常有以下三种方式:
1. 先序遍历 (Pre-older Traversal): 依次访问 `根节点 -> 左子树 -> 右子树`
2. 中序遍历 (In-older Traversal): 依次访问 `左子树 -> 根节点 -> 右子树`
3. 后序遍历 (Post-older Traversal): 依次访问 `左子树 -> 右子树 -> 根节点`

## 4. 实现冒泡排序（Bubble Sort）


## 5. 实现快速排序（Quick Sort）

## 6. 二分查找（Binary Search）
[[查找#二分查找]]

## 7. 你所知道的设计模式有哪些？
1. 单例
2. 工厂模式
3. 抽象工厂模式
4. 责任链模式
5. 动态代理
6. 模板方法模式


## 8. 单例模式（Binary Search）

### 8.1 单例模式定义
在同一个系统中, 这个特殊的类只存在一个对象实例, 且该类自行创建对象实例并向整个系统提供这个实例


### 8.2 单例模式的特点
1. 构造器私有化
2. 提供指向实例的私有静态属性
3. 提供以自身实例为返回值的公共静态方法 *getInstance ()* 供外部使用这个实例

### 8.3 单例的四大原则
1. 构造器私有
2. 以静态或枚举的方式返回示例
3. 确保示例只有一个
4. 确保反序列化时不会重写构建对象

### 8.4 实现单例模式的方式
[[设计模式-单例(Singleton Pattern)#懒汉式]]
[[设计模式-单例(Singleton Pattern)#饿汉式]]

## 9. 工厂设计模式（Factory）
### 9.1 什么是工厂设计模式？
### 9.2 简单工厂（Simple Factory）
### 9.3 工厂方法（Factory Method）
### 9.4 抽象工厂（Abstract Factory）

## 10. 代理模式（Proxy）
### 10.1 什么是代理模式？
### 10.2 为什么要用代理模式？
### 10.3 有哪几种代理模式？
### 10.4 简述动态代理的原理，常用的动态代理的实现方式

# Java 基础

## 1. 如何理解 OOP 面向对象
面向对象思想是指将计算机中的东西比喻为生活中的一样务, 一个对象. 现实生活中每个对象都有属性或行为, 这也对应着计算机中的属性和方法 (函数)
面向对象有三大特性, 分别封装/继承/多态
封装: 指将一个对象的属性和实现细节隐藏, 只对外提供公共的访问方式
继承: 是指一个类可以通过继承获得所有父类的属性和方法并在此基础上进行功能的扩展
多态: 子类可以通过重写继承自父类的方法, 以满足自身的需求. 多态也如其名, 同样的方法可以有多种形态, 体现出了极高的灵活性

## 2. 你是怎样理解多态的？什么地方用过？
各个子类可以通过重写父类方法的方法, 对同一个方法做出不同的响应形态, 这就是多态.

## 3. 重载与重写有什么区别?
重载是在一个类中, 定义多个同名的方法, 根据传入参数的不同做出不同的处理
重写是指子类在继承父类后对所继承的方式进行改写使得更适合自身的实际需求

## 4. 接口与抽象类的区别
1. 类可以实现多个接口, 但只能继承一个类
2. 抽象类中有构造方法, 接口中不能有构造方法
3. 抽象类可以包含抽象方法和具体实现方法, 而接口只能定义抽象的方法
4. 抽象类中可以包含成员变量, 而接口中不能
5. 从设计层面上讲, 抽象类是一种类的模板设计. 接口则是行为的抽象, 是一种行为规范

## 5. 深拷贝与浅拷贝的理解

## 6. 举例说明封装和继承是怎么回事?
封装: 假设我写了一个计算器 Calculator 类, 这个类提供了各种计算的公共方法. 我向提供给别人用, 只需要告诉其他人这个方法是做计算使用的, 至于我使用什么样的方式实现不需要关注, 直接使用就行. 将具体实现方式封装, 更好的关注眼下的代码
继承: 子类继承父类, 是指直接将父类的属性和方法拿过来直接使用, 减少代码的重复开发达到高复用的同时, 还可以自己扩展添加自己的属性和方法. 对于想要根据不同的业务需求拓展不同的方法时, 只需要继承然后在后面添加新的方法即可

## 7. Sleep 和 wait 在线程里有什么区别？
Sleep 是指将线程暂时休眠, 它必须指定一个时间参数, 到时间后自动唤醒继续执行业务.**不释放锁**, 它是 Thread 类的静态方法
Wait 是指线程**释放当前持有的锁**, 进入线程池等待其他线程 notify. 它是 Object 的方法, 必须搭配 synchronized 关键字使用

## 8. 什么是自动拆装箱？ Int 和 Integer 有什么区别?
自动装拆箱是在 jdk1.5 后新加入的特性, 它可以使包装类和基本数据类型进行运算时自动的进行类型转换
Int 和 Integer 的区别
1. Int 是存储在 Java 栈中的基本数据类型, 它本身并不是一个对象. 而 Integer 是一个必须初始化后才能使用的对象, 它是对象的引用
2. Integer 默认值为 null, int 默认值是 0

## 9. \==和 equals 区别
1. \== 代表直接比较两个对象的地址值, 如果是同一个内存地址返回 true, 只有在基本数据类型比较时是比较数组
2. Equals 默认也是是比较对象的地址值, 如果地址值一样, 返回 true, 但是不同的类可以对他进行重写, 例如 String 中在地址值不同的情况下还会对对象的值进行比较


## 10. String 能被继承吗？为什么用 final 修饰？
String 类是使用 final 关键字修饰的, final 关键字可以用来修饰变量/类/方法, 被 final 修饰的方法不能够重写, 类不能被继承及变量不可被修改;
正是由于 String 类型的不可变性, 才能使得 jvm 中可以实现字符串常量池, 不同的字符串变量指向同样的字面量时, 都指向字符串常量池中的同一个对象, 这样做的好处是在运行期间能节约内存, 提升程序的运行速度; 在修改某一个字符串变量时, 直接指向一个新的对象不会影响原对象

## 11. String buffer 和 String builder 区别
StringBuffer 与 StringBuilder 都是 Java 中的可变字符串类; 与 String 的区别是, 这两个类的对象能够被多次修改, 并且不产生新的未使用的对象
主要区别有:
1. 线程安全: StringBuffer 的所有公共方法都是使用 synchronized 关键字进行修饰的, 在多线程环境下使用 StringBuffer 能够保证线程安全
2. ToString 方法区别: StringBuffer 在每次对象被修改时, 都会使用最新的对象更新缓存区 `toStringCache`, 使用 toString 方法获取字符串对象时直接从缓存区读取
3. 使用场景不同: 在多线程操作字符串缓冲区下大量数据时使用 StringBuffer 保证线程安全, 其他情况下使用 StringBuilder 尽量保证程序运行速度

## 12. Final、finally、finalize
`final` 是 Java 中的关键字, 它可以用来修饰变量/类/方法, 被 final 修饰的方法不能够重写, 类不能被继承及变量不可被修改;
`finally` 是 Java 异常捕获分支 try-catch 中用于表示无论是否有异常都会执行的一个代码片段, 通常使用 finally 来做释放资源操作 (锁/连接池等)
`finalize()` 是 Java 程序中超类 Object 的一个方法, 在 GC 对一个对象进行回收前, 会调用这个方法

## 13. Object 中有哪些方法
1. `equals()` 比较方法
2. `toString()` 将对象转换为字符串常量
3. `finalize()` GC 回收对象前调用
4. `hashCode()` 获得对象的 hash 值
5. `wait()` 阻塞当前线程, 直到其他线程使用 `notify()` 或者 `notifyAll()` 唤醒
6. `notify()` 唤醒线程
7. ....

## 14. 说一下集合体系？ArrarList 和 LinkedList 区别
[[集合#ArrayList/LinkedList/Vector 有什么区别?]]

## 15. HashMap 底层源码，数据结构
> HashMap 在 1.8 之后采用**数组 + 链表 + 红黑树**的数据结构

[[集合#源码解析]]

属性:
- 默认数组的长度是 16 (1 << 4)
- 数组组大容量 2^30
- 默认加载因子 0.75
- 树化的阈值链表长度大于 8
- 红黑树个数小于 6 反树化

当 hash 结果出现 hash 碰撞, 他会在同一个数组 (存放 hash) 下方添加一个链表追加元素, 当 hash 碰撞非常频繁, 链表的长度大于 8 或者是数组长度大于 64 就转为红黑树

底层封装了 Entry 对象, entry 内存放了 hash, key, val 和下个节点的指针

## 16. HashMap 底层是数组+链表+红黑树，为什么要用这几类结构呢？
[[集合#为什么 HashMap 底层采用数组+链表/红黑树?]]


## 17. HashMap 和 HashTable 区别
1. HashMap 继承 `AbstractMap` 类, HashTable 继承 `Dictionary` 类, `Dictionary` 已经被标注为过时的类
2. HashTable 的大多数方法都是使用 synchronized 修饰的同步方法, 它能够保证在多线程环境下的线程安全. 而 HashMap 则不是, 对于 HashMap 解决线程安全采用并发容器类 `ConcurrentHashMap` 类 [[day02_JUC辅助工具类#并发容器类]]
3. HashMap 是允许 key 与 value 值都为 null 的, 而 HashTable 键值对都不能为空
4. HashTable 默认容量 11, HashMap 默认容量 16
5. HashTable 扩容容量为 2 倍+1, HashMap 为 2 倍

## 18. 线程的创建方式
1. 实现 `Runable` 接口
2. 实现 `Callable` 接口
3. 继承 `Thread` 类
4. 通过线程池 `ThreadPoolExcutor` 获取
5. [[多线程#开启新线程的方式]]
 
## 19. 线程的状态转换有什么？（生命周期）
线程的状态转换指的是一个线程在不同的条件下发生的, 在 jdk 的 `Thread` 类中, 关于线程状态的定义有以下六种
1. `NEW` 一个线程在还没有启动前都处于这个状态
2. `RUNABLE` 调用线程的 `.start()` 方法, 线程在 JVM 中开始执行
3. `BLOCKED` 线程被阻塞, 等待获取锁
4. `WAITING` 无限期等待, 直到其他线程唤醒
5. `TIMED_WAITING` 限期等待, 无需等待其他线程唤醒, 在一定时间后系统自动唤醒
6. `TERMINATE` 线程终止, 线程结束运行

## 20. Java 中有几种类型的流
1. 从功能上区分: 节点流, 处理流
2. 从数据流方向区分: 输入流 (Read/InputStream), 输出流 (Write/OutputStream)
3. 从处理数据单位区分: 字符流 (Read/Write), 字节流 (InputStream/OutputStream)

## 21. 请写出你最常见的 5 个 RuntimeException
1. `ClassNotFoundException` 类未找到异常
2. `NullPointerException` 空指针异常
3. `SQLException` SQL 操作异常
4. `ClassCastException` 类型转换异常
5. `IllegalArgumentException` 非法参数异常

## 22. 谈谈你对反射的理解
反射就是允许在 Java 运行期间获取任意一个类的所有属性及方法, 反射的最主要作用就是获取 Java 程序启动后才会确定使用到的类, 反射机制为 Java 带来了灵活性, 避免将程序写死到代码中
反射的基本原理就是在运行期间通过 [[Java Virtual Machine]] 获取到这个类的 `.class` 文件 , 从而获得这个类的全部信息并可以对其操作

## 23. 什么是 java 序列化，如何实现 java 序列化？
Java 序列化就是将 Java 对象写出文件持久化到硬盘中的过程, 在 Java 中可以通过类实现 `Serializable` 接口的并指定版本号的形式来实现序列化.

# Java 高级

## 1. JVM 内存分哪几个区，每个区的作用是什么?
1. 方法区 (元空间): 用于存放类的原始模板消息, 元空间是一个共享区域
2. 堆: 用于存放对象实例和数组, GC 主要工作区域, 内部又分为新生代与老年代
3. 本地方法栈: 用于存放 Java 程序中 `native` 关键字修饰的方法
4. Java 方法栈: 分配给每个线程运行时的内存, 主要存储本地变量, 记录入栈/出栈及栈帧数据; 它是线程私有的
5. PC 寄存器: 每个线程私有的一个程序计数器, 用于记录代码行号, 指向即将执行的代码 [[Java Virtual Machine#PC 寄存器]]

## 2. Java 中垃圾收集的方法有哪些?
1. 标记清除算法: 从 GC Roots 根节点开始遍历, 将这个节点引用到的对象添加标记, 再遍历结束后, 没有被标记的对象都为不可达对象, 可以被回收 (回收空间碎片化)
2. 标记整理算法: 在标记清除方法的基础上, 将引用到的对象整理到内存的一边后, 清除所有边界外的空间
3. 复制算法: 将内存空间分为两份, 清理前将存活的对象复制到两份空间中的另一个区, 将这个区域的对象全部清除
4. 分代收集算法: 针对不同作用的分区, 采用不同的算法进行回收, hotSpot 就是采用这种算法

## 3. 如何判断一个对象是否存活? (或者 GC 对象的判定方法)
1. 引用计数法: 给对象添加一个计数器, 每次被引用时计数器+1 释放对象时-1, 当某个对象计数为 0 时即代表可以回收 (会产生循环引用导致无法回收对象) [[Java Virtual Machine#引用计数法]]
2. 可达性分析法: 使用一些被称为 GC Roots 的根节点作为起点, 依次遍历他们所引用的对象, 将被引用的对象添加标记. 当一个对象没有标记则证明未被引用, 可以回收 [[Java Virtual Machine#可达性分析算法]]

## 4. 什么情况下会产生 StackOverflowError（栈溢出）和 OutOfMemoryError（堆溢出）？怎么排查？
1. 在递归调用, 没有设置停止条件或者条件设置不合理, 出现栈溢出
2. 在使用 apache 旗下的 Excel 操作类 poi 时, 如果报表数据过大就会产生堆溢出 [[EasyExcel#概述]]或者查询数据库时的 `findAll()` 方法, 一次性将所有数据加载到堆内存, 可能引发堆溢出故障
3. 通过导出 dump 文件, 使用 MAT 工具的方式对可能的内存泄漏进行分析 [[Java Virtual Machine#定位分析堆 OOM 问题]]

## 5. 什么是线程池，线程池有哪些（创建）？
线程池是用于存放线程资源的容器, 线程并非一次性的资源, 通过线程池可以对线程资源完成复用. 在需要使用到多线程时直接从线程池中获取, 避免重复创建及销毁线程, 提高程序的响应速度. 通过线程池也能做到对线程的统一管理
线程池的创建方式有:
1. 通过 `Executors` 工具类的静态方法来创建线程池
2. 使用 `ThreadPoolExecutor` 类创建线程池

## 6. 为什么要使用线程池
1. 线程是一种昂贵的资源, 它的创建及销毁都要付出高昂的代价, 为了避免频繁的创建及销毁, 产生了线程池技术
2. 通过线程池可以对已经创建的线程资源进行复用, 避免系统重复创建及销毁线程, 拖慢响应速度
3. 通过线程池可以对一个系统中的线程资源做到统一维护和管理, 需要使用多线程时直接从线程池中获取

## 7. 线程池底层工作原理
[[day03_线程池与volatile#线程池工作原理]]

## 8. ThreadPoolExecutor 对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？

ThreadPoolExecutor 有七大核心参数, 他们分别是:
1. 常驻核心线程数 `corePoolSize`
2. 最大执行线程数 `maximumPoolSize`
3. 空闲线程存活时间 (非常驻核心线程) `KeepAliveTime`
4. 空闲线程存活时间单位 `TimeUnit`
5. 线程池工厂 `ThreadPoolFactory` 指定创建线程时使用的线程工厂
6. 任务队列 `ArrayBlockingQueue`, 存放等待分配线程执行的任务
7. 拒绝策略 `RejectedExecutionHandler`, 任务饱和后的拒绝策略
8. [[day03_线程池与volatile#创建线程池的七大核心参数]]

通常情况下, 建议核心线程数与最大执行线程数的数量保持一致, 避免系统运行中的线程创建于关闭, 保证系统的最快响应 [[day03_线程池与volatile#如何合理设置线程最大线程数和核心线程数?]]

拒绝策略有:
1. `AbortPolicy` 拒绝执行策略: 抛出 `rejectExecutException ` 异常, 拒绝执行
2. `DiscardPolicy` 丢弃任务策略: 默默丢弃无法处理的任务, 不抛出异常
3. `DiscardOldestPolicy` 丢弃任务队列中等待最久的任务, 并执行新任务
4. `CallrunsPolicy` 让调用者所属线程处理该任务

## 9. 常见线程安全的并发容器有哪些？
1. `ConcurrentHashMap`
2. `CopyOnWriteArrayList`
3. `CopyOnWriteSet`

## 10. Atomic 原子类了解多少？原理是什么？
[[day02_JUC辅助工具类#Atomic 原子类]]

## 11. Synchronized 底层实现是什么？Lock 底层是什么？有什么区别？
[[多线程#Lock 和 synchronized 的区别]]

## 12. 了解 ConcurrentHashMap 吗? 为什么性能比 HashTable 高，说下原理
ConcurrentHashMap 是保证线程安全的 HashMap 并发容器类, 它在底层使用了 volatile 关键字对 table 变量进行修饰, 在保证内存中变量修改的可见性的同时保证了一定的性能

## 13. ConcurrentHashMap 的 put 流程

## 14. 了解 volatile 关键字不？
[[day03_线程池与volatile#简介]]

## 15. Synchronized 和 volatile 有什么区别？
[[day03_线程池与volatile#Volatile 与 synchronized 的区别]]

## 16. Java 类加载过程?
JVM 在加载类时会经过一下几个必须的步骤:
1. 加载: 将类的二进制文件从储存媒介 (磁盘、网络) 中读取到内存中
2. 验证: 验证类的二进制文件是否符合虚拟机规范
3. 准备: 为类的静态变量分配内存并将其初始化为默认值
4. 解析: 替换类中的符号引用为直接引用
5. 初始化: 执行类的初始化方法, 并将类的静态变量赋值为指定的值
6. 详见 [[Java Virtual Machine#类的加载过程]]

## 17. 什么是类加载器，类加载器有哪些?
类加载器是 Java 虚拟机中的一种机制, 负责将类的二进制文件 `.class` 加载到内存中
Java 中的类加载器有: [[Java Virtual Machine#类加载器的分类]]

## 18. 简述 java 内存分配与回收策略以及 Minor GC 和 Major GC（full GC）

JVM 使用垃圾回收器 (jdk8 为 Parallel GC ) 来自动管理内存, 垃圾回收器的工作原理是通过标记后清除的方法来回收不再使用的内存

在 JVM 中, 内存可以分为新生代与老年代两个部分: 新生代内存较小, 分为伊甸园区 Eden 和两个存活区 Survivor, 对象在新生代中存活的时间较短, 如果在 Minor GC 只会仍然存活便会被晋升到老年代, 老年代的内存空间较大, 一般存放长期存活的对象

Minor GC 通常指新生代 GC, Minor GC 的 *stop the world* 时间较短, 因为新生代内存较小, 对象的存活率也低
Major GC 通常是指针对整个堆空间的垃圾回收, Major GC 要比 Minor GC 的时间慢得多, 因为它需要扫描整个堆内存,*stop the world* 时间更长

## 19. 如果查看死锁
1. 在命令行窗口通过 `jps` 命令查找出所有正在运行的 Java 进程及其对应的 PID
2. 使用 `jstack + PID` 命令打印出所有线程的堆栈跟踪日志信息. 如果存在死锁, 日志信息会给出 `Found one Java-level deadlock` 并给出相关信息

## 20. Java 死锁如何避免
死锁是指多个并发线程因争夺系统资源而产生互相等待的情况
1. 尽量避免使用锁或尽量减少锁的使用, 死锁情况通常由锁的滥用引起的
2. 避免在锁内执行耗时操作, 避免线饥饿并最终导致死锁 (某一线程或多个线程因为某些原因一直获取不到资源)
3. 使用可重入锁 (如 `ReentrantLock`) 可以防止由于线程的递归调用而导致的死锁
4. 使用信号量 (Semaphores) 来控制访问共享资源的线程数量 [[day02_JUC辅助工具类#Semaphore]], 避免因共享资源而引起的死锁
5. 使用定时锁 (如 RetrantLock) 在获取锁时设置超时时间, 如果超过时间没有获得锁则返回 false, 并且不会产生线程阻塞

# MySQL 数据库

## 1. SQL 的 select 语句完整的执行顺序
1. `FROM` 确定要查询的表
2. `WHERE` 从该表中过滤出符合条件的数据
3. `GROUP BY` 将检索出的数据按照指定的字段进行分组
4. `HAVING` 过滤分组后的数据, 只保留符合条件的数据
5. `SELECT` 指定要返回的字段
6. `DISTINCT` 去除掉重复的行
7. `ORDER BY` 将数据按照指定的字段进行排序
8. `LIMIT` 限制返回数据的行数

## 2. MySQL 的事务
MySQL 中的事务是一组逻辑单元, 表示将数据库中的数据从一个一致性状态更新到另一中一致性状态, 一个事务中可以包含多条 SQL 语句, 这些语句要么全部执行, 要么全部不执行
一个事务必须满足四个条件 (ACID): 原子性 (不可分割性)、一致性、隔离性、持久性
[[事务 Transaction]]

## 3. 简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别
1. MyISAM 特性
	1. MyISAM 是 MySQL 系统自带表使用的引擎
	2. MyISAM 不支持外键和事务
	3. MyISAM 只缓存索引, 不缓存真实数据
2. InnoDB 特性
	1. InnoDB 是 MySQL 默认的存储引擎
	2. InnoDB 支持事务操作
	3. InnoDB 支持行级锁
	4. InnoDB 支持外键

## 4. 悲观锁和乐观锁的怎么实现？
- Java 的乐观锁是使用 [[day03_线程池与volatile#CAS]] 实现的
- 悲观锁则可以通过操作数据库前上锁实现

## 5. 你们公司有哪些数据库设计规范？
1. 编码集必须使用 `utf-8mb4`
2. 表中必备字段 `id create_time modified_time` 
3. 表达是与否概念的字段必须以 `is_xxx` 的格式命名, 数据类型为 `tinyint`, 0 表示否, 1 表示是
4. 小数类型必须采用 `bigDecimal`, 禁止使用 int 或 float (存在精度问题)
5. 必须为数据库中的每个对象添加注释, 以帮助理解其用途

## 6. 有没有设计过数据表? 你是如何设计的?
1. 确定表的目的, 明确表要存储的数据类型和信息以及他们之间的关系
2. 明确表的结构, 确保每一列都由一个名称和数据类型
3. 确定主键, 主键是表中每条数据的唯一标识
4. 设置约束 (NOT NULL 或 UNIQUE 等) 帮助维护数据的完整性
5. 为表中的每一列添加注释, 以帮助理解其作用
6. 如果这个表将存储大量的数据, 应该考虑为表建立索引以提高查询效率

## 7. 聚簇索引与非聚簇索引有什么区别
1. 聚簇索引的叶子节点将索引列的数据与其他列的数据存储在一起, 这样就形成了一个"聚簇", 找到索引也就找到了数据. 
2. 非聚簇索引则将索引列的数据与其他列的数据分开存储, 它的叶子节点存储主键 id, 获得主键 id 后再回表

## 8. 索引的底层实现是什么？什么情况下会索引失效？
MySQL 索引的底层实现有几种方式 (B+Tree, B-Tree, Hash, R-Tree 等), 具体取决于使用的存储引擎
导致索引失效的情况有:
1. 表的数据量太少, 在执行搜索时 MySQL 优化器认为走索引所带来的额外开销大于全表扫描时, 会放弃索引
2. 计算、函数、类型转换都会导致索引失效
3. WHERE 条件所传入的类型与缓存中存储的类型不匹配时, MySQL 优化器会自动使用 `CAST()` 函数来进行转换, 导致索引失效
4. 在索引列上使用范围或不等式条件时, 会导致这个索引列及其右边的所有索引列失效 (在联合索引中, 范围条件必须放在 where 的最右边)
5. 索引的第一个字段就以通配符 `%` 开头, 会导致无法通过 B+Tree 来快速定位目标位置, 需要依次全盘扫描, 索引失效

## 9. B+tree 与 B-tree 区别
B+Tree 和 B-Tree 都是自平衡的二叉搜索树, 他们的主要区别就是 B+Tree 的叶子节点存储数据本身, 而非叶子节点仅存储指向子节点的指针

在 B+Tree 中，叶节点的指针是连续的，因此可以通过单次 IO 操作就能访问到所有的数据记录。而在 B-Tree 中，每个节点都存储了数据记录的指针，因此需要多次 IO 操作才能访问到所有的数据记录。这也是为什么 B+Tree 比 B-Tree 更适合作为磁盘上的索引结构的原因。 #GOTO

## 10. 以 MySQL 为例 Linux 下如何排查问题?
1. 检查 MySQL 服务是否已开启, 通过 `ps -a|grep mysql` 命令查看进程是否在运行
2. 通过查看 MySQL 服务日志文件, 来了解问题的具体原因 `tail -f /var/log/mysql/error.log`
3. 可以通过外界 MySQL 连接工具登录到 MySQL 服务器, 确定是否能够正常连接
4. 通过 `CHECK TABLE` 指令来检查数据表是否损坏, 如果损坏则通过 `REPAIR TABLE` 来修复表
5. 检查 SQL 语法是否出错, 可以通过 `EXPLAIN` 命令来查看 SQL 执行计划, 了解问题的具体原因

## 11. 如何处理慢查询
1. 优化 SQL 语句: 通过 `EXPLAIN+SQL` 指令来查看 SQL 的执行计划, 考虑哪些地方可以优化
2. 建立合理的索引: 可以通过 SQL 执行计划来查看当前 SQL 的索引使用情况, 如果没有使用索引则可以考虑为其建立索引
3. 减少查询的数据量: 使用 `LIMIT` 来限制结果集的大小, 或使用分组和统计函数来对数据做聚合处理

## 12. 数据库分表操作
通过数据库分表来减少单表的数据量, 从而提高查询性能和降低维护成本. 常见的分表有几种常见的方式
1. 按照时间分表: 将数据按照时间字段的不同拆分, 例如每月一张表或者每年一张表等
2. 按字段值范围分表: 将数据按照某个字段的数据范围进行分表, 例如 id 为 1~1000 的一张表, 1001~2000 的一张表
3. 按照哈希结果分表: 将数据按照哈希结果分别存储不同的表中
4. 按照模数结果分表: 如 id % 10 = 0 的数据放一张表, id % 10 =1 的数据放一张表
5. 通过 ShardingSephere-JDBC 与 ShardingSephere-Proxy 来实现数据库的数据分片及读写分离
6. 垂直分片 (专库专用) 与水平分片 (按照不同规则分散到不同的库与表中); 可以在专库专用的基础上进行水平分片

## 13. MySQL 优化
1. 禁止使用 \* 号查询所有数据
2. WHERE 条件后不能使用函数
3. 模糊查询不能以 % 开头
4. 不适用 OR 条件, 它会导致索引失效
5. 小表驱动大表

## 14. SQL 语句优化案例

## 15. 常见面试 SQL



# Java Web
## 1. Http 常见的状态码有哪些？
1. 200 成功
2. 404 资源未找到
3. 503 服务不可用
4. 403 无权限
5. 500 服务器内部错误

## 2. GET 和 POST 的区别？
GET 和 POST 是 HTTP 协议中两种常见的请求方法。他们的主要区别有:
1. ~~GET 请求无法携带请求体, 只能通过 uri 进行参数的传递. GET 更常见于获取数据的请求. 它将所有的请求参数都放在 uri 中, 隐私性及安全性相较于 POST 更低. GET 通过 uri 传递参数, 而通常浏览器与服务器对于 uri 都有长度限制~~
2. GET 请求方法常用于请求数据, 例如获取搜索结果, 获取用户信息等场景. GET 请求有以下常见的特性
	1. 请求参数会被存放到 uri 中进行传递, 所以它不应该在处理敏感信息时使用, 容易被拦截或泄漏 (数据不安全)
	2. GET 请求参数有大小限制 (2KB 以内)
	3. 参数信息会被完整的保存到浏览器中
3. POST 请求常用于向浏览器发送数据, 例如提交表单或上传文件等. POST 请求有以下特点
	1. 请求参数会被存放在请求体中
	2. 参数信息不会被浏览器完整的保存
	3. POST 请求没有长度限制
4. 简而言之, GET 请求更合适用于从浏览器中获取数据, 而 POST 请求则更适用于发送数据到服务器中

## 3. Cookie 和 Session 的区别
1. 存储位置不同: cookie 存储在客户浏览器端的一小段数据, 而 session 存储在服务器端
2. 生命周期不同: cookie 的生命周期通常比 session 更长, session 通常只在用户正在使用网站时有效
3. Cookie 只能存放 String 类型 (ASCII), session 则可以存储任意类型的对象


# Java 框架
## 1. 简单的谈一下 SpringMVC 的工作流程？
[[SSM阶段面试#24. 简单的谈一下 SpringMVC 的工作流程]]

## 2. 说出 Spring 或者 SpringMVC 中常用的 5 个注解，并解释含义
1. @RestController 标记一个类为 Controller 控制器类并以 Json 字符串的形式响应数据
2. @RequestMapping 将 Web 请求映射到方法或类上
3. @Autowaired 自动注入对象
4. @Component 将标记的类注入到 IoC 容器中
5. @Service 业务逻辑层标记
6. @Aspect 声明一个切面类
7. @PathVariable 从 uri 路劲中获取指定的值

## 3. 简述 SpringMVC 中如何返回 JSON 数据
使用 `@RestController` 标记类或者 `@ResponseBody` 标记方法即可返回 Json 数据

## 4. 谈谈你对 Spring 的理解


## 5. Spring 中常用的设计模式

## 6. Spring 循环依赖问题
### 6.1 请解释一下 spring 中的三级缓存
### 6.2 三级缓存分别是什么? 三个 Map 有什么异同?
### 6.3 什么是循环依赖? 请你谈谈? 看过 spring 源码吗?
Spring 循环依赖是指 bean 自己依赖自己或者两个 bean 之间相互依赖对方

### 6.4 如何检测是否存在循环依赖? 实际开发中见过循环依赖的异常吗?
### 6.5 多例的情况下, 循环依赖问题为什么无法解决?

## 7. 介绍一下 Spring bean 的生命周期、注入方式和作用域

## 8. 请描述一下 Spring 的事务管理

## 9. MyBatis 中 #{}和${}的区别是什么？
1. `#{}` 在底层 JDBC 中使用了 prepareStatement 预编译对象对 SQL 语句进行处理, 通过占位符及 `set()` 方式来进行赋值
2. 使用 `#{}` 可以有效的防止 SQL 注入, 提高系统的安全性
3. 由于 `#{}` 会自动为传入的参数添加引号, 在需要表示字段名及表名的场景下也就无法使用 `#{}`, 这种情况就可以选择使用 `${}`

## 10. Mybatis 中一级缓存与二级缓存？

缓存的分类：
-  一级缓存, 默认开启. 针对同一个 SqlSession 级别
-  二级缓存, 默认关闭. 针对同一个 SqlSessionFactory（mapper 级别）

缓存的访问步骤：
1.  从数据库从获取数据
    1.  将数据存放到一级缓存
    2.  在关闭 SqlSession 前,将一级缓存的数据存放到二级缓存
2.  再次访问数据
    1.  先从二级缓存中查找
    2.  再从一级缓存中查找
    3.  若都没有, 再从数据库中查询并重复上面缓存操作

缓存失效的场景：
1. 执行增删改操作后, 会将原缓存数据清空
2. 事务提交后, 清空缓存
3. `sqlSession.clearCache()` 手动清空注解

## 11. MyBatis 如何获取自动生成的 (主) 键值?
在 `SELECT` 标签中添加 `userGeneratedKeys=true keyProperty=id` 即可获取自动生成的主键值

## 12. 简述 Mybatis 的动态 SQL，列出常用的 6 个标签及作用
1. `where` 动态的插入 WHERE 关键字并解决 SQL 语句行首出现的 AND 或 OR 关键字
2. `if` 简单的分支判断, 与 `where` 标签搭配使用
3. `foreach` 对集合进行遍历, 通常搭配 IN 关键字使用, 可以通过它来实现批量删除等操作
4. `set` 动态的在行首插入 SET 关键字, 并且或自动删除多余的逗号
5. `trim` 自定义 where 元素
6. `sql` 提取重复的 SQL 片段, 通过 `include field` 引入 SQL 片段即可完成对 SQL 的复用

## 13. Mybatis 如何完成 MySQL 的批量操作, 举例说明
通过动态 SQL 的 `foreach` 标签与 IN 搭配使用, 即可完成 SQL 的批量操作. 例如想实现一个批量删除需求, 只需要将 ids 封装为一个集合并传入, 使用 `foreach` 遍历这个集合的同时为它设置分隔符、左右括号等属性, 结合 IN 关键字即可轻松完成批量处理;
```xml
<!-- 批量删除供应商 -->  
<delete id="batchRemoveSupplier">  
    DELETE    FROM jxc.t_supplier    WHERE t_supplier.supplier_id
    IN    
    <foreach collection="ids" item="id" separator="," open="(" close=")">  
        #{id}    
    </foreach>  
</delete>
```

## 14. 谈谈怎么理解 SpringBoot 框架？
SpringBoot 是一个实现快速开发 Spring 应用的脚手架, 它通过配置类+注解的方式, 大大降低了系统中的 XML 配置, 大大降低了 Spring 应用开发的周期及前期配置. SpringBoot 还提供了一组"开箱即用"的特性, 可以自动配置 Spring 框架和第三方库, 使得可以快速上手开发应用程序

## 15. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？
SpringBoot 的核心注解是 `@SpringBootApplication`, 用它标记的类为这个 SpringBoot 程序的统一入口, 也就是启动类. 它是一个混合注解, 主要组成注解及作用是:
1. `@SpringBootConfiguration` 标注当前类是配置类
2. `@EnableAutoConfiguration` 开启自动配置, 将符合自动装配条件的 bean 加载到 IoC 容器中
3. `@MapperScan` 指定自动装配的包, 默认为启动类所在包及其子包

## 16. Spring Boot 自动配置原理是什么？
[[SpringBoot#自动装配原理]]

## 17. SpringBoot 配置文件有哪些？怎么实现多环境配置？
1. Bootstrap 启动引导文件
2. Application 配置文件
3. 通过 `application-dev` 等命名方式, 为不同的环境配置不同的配置文件, 需要切换环境是仅需在主配置文件 `application.ymal` 中设置 `spring.profiels.active=dev` 即可完成多环境配置

## 18. SpringBoot 和 SpringCloud 是什么关系
SpringCloud 必须依赖 SpringBoot 运行, 而 SpringBoot 则可以独立运行

## 19. SpringCloud 都用过哪些组件？介绍一下作用
- Nacos 作为服务中心和配置中心使用
- OpenFeign 远程过程调用组件
- Gateway 网关, 用于鉴权、过滤及路由
- Sentinel 服务降级/熔断/限流
- Zipkin (Sleuth) 分布式链路调用追踪

## 20. Nacos 作用以及注册中心的原理
Nacos 是一个支持动态服务发现、配置管理、服务状态管理的服务型注册中心, 它的作用主要是服务注册中心及配置中心. 在微服务架构中，注册中心是服务治理的核心组件，服务的提供者将自己的信息（服务名称、版本、地址、端口号等）信息注册到注册中心中, 服务的消费者通过服务中心来发现和调用服务. 注册中心也能够实时监控服务的运行状态

## 21. Feign 工作原理
OpenFeign 是一个声明式的、模块化的 HTTP 客户端, 用于简化与 HTTP 服务的交互, 它通过注解的方式来生成客户端, 能够让我们向调用本地方法一样的去调用远程方法
OpenFeign 内置了 Ribbon, 它可以帮助 Feign 基于某些规则来实现负载均衡的调用远程服务. OpenFeign 还内置了 Hystrix, 它可以帮助 Feign 在出现熔断的情况下进行兜底管理

# Redis 数据库
## 1. 介绍下 Redis？Redis 有哪些数据类型？
Redis 是一个开源的非关系型数据库, 常被用于数据存储、缓存及消息中间件. 它支持多种类型的数据结构, 例如字符串、哈希、列表、集合、有序集合等

## 2. Redis 提供了哪几种持久化方式？
Redis 提供了两种持久化方式, 分别是 RDB (Redis Database) 和 AOF (Append only file)
RDB: 在指定的时间范围内, 将内存中的数据快照写入磁盘
AOF: 记录所有增删改操作日志, 在服务器重启时重放日志即可恢复数据

## 3. Redis 为什么快？
Redis 之所以快, 是因为它的数据全部存储在内存中, 直接从内存中获取数据要比从磁盘中获取数据快得多
此外, Redis 采用单线程对请求进行处理, 这看起来像是一个限制, 但实际上它省去了频繁的上下文切换与并发控制机制, 使它变得非常高效

## 4. Redis 为什么是单线程的?
单线程的设计是为了让 Redis 更加简单、高效和安全;
- 单线程的设计能够使得 Redis 的代码更加简单, 降低出错概览
- 单线程能够使得 Redis 的并发性能更好, 因为不存在多线程间的竞争与切换
- 单线程能够使得 Redis 的并发访问更加安全与高效, 因为它不需要使用锁来保证数据的一致性

由于 Redis 是单线程的, 所以它不能充分的利用多核处理器的性能, 针对这一点, Redis 提供了分片功能, 可以将数据分步在多个 Redis 实例中, 从而提高并发性能

## 5. Redis 服务器的的内存是多大?
Redis 默认的内存是 0, 也就是说, 默认情况下 Redis 服务器不会限制使用内存的大小.
如果没有对 Redis 设置最大内存限制, 它会一直使用系统可用内存, 在生产环境下可能会造成内存溢出或性能问题, 具体大小需要根据实际应用需求调整, 并不是越大越好

## 6. 为什么 Redis 的操作是原子性的，怎么保证原子性的？
Redis 采用乐观锁的思想来保证操作的原子性, Redis 会采用 `watch` 命令来监视键, 在一个操作事务提交前它会检查该键的值是否已被修改, 如果在开始事务前已经被修改, 则会返回一个错误

## 7. Redis 有事务吗？
Redis 中可用通过 `MULTI` 指令来开启事务, 通过 `EXEC` 只来执行任务队列中的指令

## 8. 使用 Redis 作为缓存，Redis 数据和 MySQL 数据库的一致性如何实现？
1. 监听 biglog
2. 在数据库增删改时发送 mq 消息
3. [[Canal]] 组件

## 9. 缓存击穿，缓存穿透，缓存雪崩的原因和解决方案？(或者说使用缓存的过程中有没有遇到什么问题，怎么解决的）
[[Redis#Redis 应用中产生的问题]]

## 10. 哨兵模式是什么样的？
[[Redis#哨兵模式 Sentinel]]

## 11. Redis 常见性能问题和解决方案？
1. Redis 采用单线程设计, 所以它不能充分的利用多核处理器的性能, 针对这一点, Redis 提供了分片功能, 可以将数据分步在多个 Redis 实例中, 从而提高并发性能

## 12. MySQL 里有大量数据，如何保证 Redis 中的数据都是热点数据？Redis 内存淘汰策略
[[Redis#Redis 内存淘汰策略]]

## 13. Redis 集群方案应该怎么做？都有哪些方案？
