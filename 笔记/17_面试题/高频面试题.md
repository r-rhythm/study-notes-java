# 数据结构/设计模式

## 1. 怎么理解时间复杂度和空间复杂度？

## 2. 数组和链表结构简单对比？
- 数组直接通过下标进行数据查询, 效率更高. 但数组容量达到临界值后, 再添加数据只能进行扩容, 效率更低
- 链表通过存储指针的形式进行数据关联, 这样做的好处是插入及其方便, 只需要存储指针. 但查询效率不及数组
- [[集合#ArrayList/LinkedList/Vector 有什么区别?]]

## 3. 怎么遍历一个树

## 4. 实现冒泡排序（Bubble Sort）

## 5. 实现快速排序（Quick Sort）

## 6. 二分查找（Binary Search）

## 7. 你所知道的设计模式有哪些？
1. 单例
2. 工厂模式
3. 抽象工厂模式
4. 责任链模式
5. 动态代理
6. 模板方法模式


## 8. 单例模式（Binary Search）

### 8.1 单例模式定义
> 在同一个系统中, 这个特殊的类只存在一个对象实例, 且该类自行创建对象实例并向整个系统提供这个实例


### 8.2 单例模式的特点
1. 构造器私有化
2. 提供指向实例的私有静态属性
3. 提供以自身实例为返回值的公共静态方法 *getInstance ()* 供外部使用这个实例

### 8.3 单例的四大原则

### 8.4 实现单例模式的方式
[[设计模式-单例(Singleton Pattern)#懒汉式]]
[[设计模式-单例(Singleton Pattern)#饿汉式]]

## 9. 工厂设计模式（Factory）
### 9.1 什么是工厂设计模式？
### 9.2 简单工厂（Simple Factory）
### 9.3 工厂方法（Factory Method）
### 9.4 抽象工厂（Abstract Factory）

## 10. 代理模式（Proxy）
### 10.1 什么是代理模式？
### 10.2 为什么要用代理模式？
### 10.3 有哪几种代理模式？
### 10.4 简述动态代理的原理，常用的动态代理的实现方式

# Java 基础

## 1. 如何理解 OOP 面向对象
面向对象思想是指将计算机中的东西比喻为生活中的一样务, 一个对象. 现实生活中每个对象都有属性或行为, 这也对应着计算机中的属性和方法 (函数)
面向对象有三大特性, 分别封装/继承/多态
封装: 指将一个对象的属性和实现细节隐藏, 只对外提供公共的访问方式
继承: 是指一个类可以通过继承获得所有父类的属性和方法并在此基础上进行功能的扩展
多态: 子类可以通过重写继承自父类的方法, 以满足自身的需求. 多态也如其名, 同样的方法可以有多种形态, 体现出了极高的灵活性

## 2. 你是怎样理解多态的？什么地方用过？
各个子类可以通过重写父类方法的方法, 对同一个方法做出不同的响应形态, 这就是多态.

## 3. 重载与重写有什么区别?
重载是在一个类中, 定义多个同名的方法, 根据传入参数的不同做出不同的处理
重写是指子类在继承父类后对所继承的方式进行改写使得更适合自身的实际需求

## 4. 接口与抽象类的区别

## 5. 深拷贝与浅拷贝的理解

## 6. 举例说明封装和继承是怎么回事?
封装: 假设我写了一个计算器 Calculator 类, 这个类提供了各种计算的公共方法. 我向提供给别人用, 只需要告诉其他人这个方法是做计算使用的, 至于我使用什么样的方式实现不需要关注, 直接使用就行. 将具体实现方式封装, 更好的关注眼下的代码
继承: 子类继承父类, 是指直接将父类的属性和方法拿过来直接使用, 减少代码的重复开发达到高复用的同时, 还可以自己扩展添加自己的属性和方法. 对于想要根据不同的业务需求拓展不同的方法时, 只需要继承然后在后面添加新的方法即可

## 7. Sleep 和 wait 在线程里有什么区别？
Sleep 是指将线程暂时休眠, 它必须指定一个时间参数, 到时间后自动唤醒继续执行业务.**不释放锁**, 它是 Thread 类的静态方法
Wait 是指线程**释放当前持有的锁**, 进入线程池等待其他线程 notify. 它是 Object 的方法, 必须搭配 synchronized 关键字使用

## 8. 什么是自动拆装箱？ Int 和 Integer 有什么区别?
自动装拆箱是在 jdk1.5 后新加入的特性, 它可以使包装类和基本数据类型进行运算时自动的进行类型转换
Int 和 Integer 的区别
1. Int 是存储在 Java 栈中的基本数据类型, 它本身并不是一个对象. 而 Integer 是一个必须初始化后才能使用的对象, 它是对象的引用
2. Integer 默认值为 null, int 默认值是 0

## 9. \==和 equals 区别
1. \== 代表直接比较两个对象的地址值, 如果是同一个内存地址返回 true, 只有在基本数据类型比较时是比较数组
2. Equals 默认也是是比较对象的地址值, 如果地址值一样, 返回 true, 但是不同的类可以对他进行重写, 例如 String 中在地址值不同的情况下还会对对象的值进行比较


## 10. String 能被继承吗？为什么用 final 修饰？
String 类是使用 final 关键字修饰的, final 关键字可以用来修饰变量/类/方法, 被 final 修饰的方法不能够重写, 类不能被继承及变量不可被修改;
正是由于 String 类型的不可变性, 才能使得 jvm 中可以实现字符串常量池, 不同的字符串变量指向同样的字面量时, 都指向字符串常量池中的同一个对象, 这样做的好处是在运行期间能节约内存, 提升程序的运行速度; 在修改某一个字符串变量时, 直接指向一个新的对象不会影响原对象

## 11. String buffer 和 String builder 区别
StringBuffer 与 StringBuilder 都是 Java 中的可变字符串类; 与 String 的区别是, 这两个类的对象能够被多次修改, 并且不产生新的未使用的对象
主要区别有:
1. 线程安全: StringBuffer 的所有公共方法都是使用 synchronized 关键字进行修饰的, 在多线程环境下使用 StringBuffer 能够保证线程安全
2. ToString 方法区别: StringBuffer 在每次对象被修改时, 都会使用最新的对象更新缓存区 `toStringCache`, 使用 toString 方法获取字符串对象时直接从缓存区读取
3. 使用场景不同: 在多线程操作字符串缓冲区下大量数据时使用 StringBuffer 保证线程安全, 其他情况下使用 StringBuilder 尽量保证程序运行速度

## 12. Final、finally、finalize
`final` 是 Java 中的关键字, 它可以用来修饰变量/类/方法, 被 final 修饰的方法不能够重写, 类不能被继承及变量不可被修改;
`finally` 是 Java 异常捕获分支 try-catch 中用于表示无论是否有异常都会执行的一个代码片段, 通常使用 finally 来做释放资源操作 (锁/连接池等)
`finalize()` 是 Java 程序中超类 Object 的一个方法, 在 GC 对一个对象进行回收前, 会调用这个方法

## 13. Object 中有哪些方法
1. `equals()` 比较方法
2. `toString()` 将对象转换为字符串常量
3. `finalize()` GC 回收对象前调用
4. `hashCode()` 获得对象的 hash 值
5. `wait()` 阻塞当前线程, 直到其他线程使用 `notify()` 或者 `notifyAll()` 唤醒
6. `notify()` 唤醒线程
7. ....

## 14. 说一下集合体系？ArrarList 和 LinkedList 区别
[[集合#ArrayList/LinkedList/Vector 有什么区别?]]

## 15. HashMap 底层源码，数据结构
> HashMap 在 1.8 之后采用**数组 + 链表 + 红黑树**的数据结构

[[集合#源码解析]]

属性:
- 默认数组的长度是 16 (1 << 4)
- 数组组大容量 2^30
- 默认加载因子 0.75
- 树化的阈值链表长度大于 8
- 红黑树个数小于 6 反树化

当 hash 结果出现 hash 碰撞, 他会在同一个数组 (存放 hash) 下方添加一个链表追加元素, 当 hash 碰撞非常频繁, 链表的长度大于 8 或者是数组长度大于 64 就转为红黑树

底层封装了 Entry 对象, entry 内存放了 hash, key, val 和下个节点的指针

## 16. HashMap 底层是数组+链表+红黑树，为什么要用这几类结构呢？



## 17. HashMap 和 HashTable 区别
1. HashMap 继承 `AbstractMap` 类, HashTable 继承 `Dictionary` 类, `Dictionary` 已经被标注为过时的类
2. HashTable 的大多数方法都是使用 synchronized 修饰的同步方法, 它能够保证在多线程环境下的线程安全. 而 HashMap 则不是, 对于 HashMap 解决线程安全采用并发容器类 `ConcurrentHashMap` 类 [[day02_JUC辅助工具类#并发容器类]]
3. HashMap 是允许 key 与 value 值都为 null 的, 而 HashTable 键值对都不能为空

## 18. 线程的创建方式
1. 实现 `Runable` 接口
2. 实现 `Callable` 接口
3. 继承 `Thread` 类
4. 通过线程池 `ThreadPoolExcutor` 获取
5. [[多线程#开启新线程的方式]]
 
## 19. 线程的状态转换有什么？（生命周期）
线程的状态转换指的是一个线程在不同的条件下发生的, 在 jdk 的 `Thread` 类中, 关于线程状态的定义有以下六种
1. `NEW` 一个线程在还没有启动前都处于这个状态
2. `RUNABLE` 调用线程的 `.start()` 方法, 线程在 JVM 中开始执行
3. `BLOCKED` 线程被阻塞, 等待获取锁
4. `WAITING` 无限期等待, 直到其他线程唤醒
5. `TIMED_WAITING` 限期等待, 无需等待其他线程唤醒, 在一定时间后系统自动唤醒
6. `TERMINATE` 线程终止, 线程结束运行

## 20. Java 中有几种类型的流
1. 从功能上区分: 节点流, 处理流
2. 从数据流方向区分: 输入流 (Read/InputStream), 输出流 (Write/OutputStream)
3. 从处理数据单位区分: 字符流 (Read/Write), 字节流 (InputStream/OutputStream)

## 21. 请写出你最常见的 5 个 RuntimeException
1. `ClassNotFoundException` 类未找到异常
2. `NullPointerException` 空指针异常
3. `SQLException` SQL 操作异常
4. `ClassCastException` 类型转换异常
5. `IllegalArgumentException` 非法参数异常

## 22. 谈谈你对反射的理解
反射就是允许在 Java 运行期间获取任意一个类的所有属性及方法, 反射的最主要作用就是获取 Java 程序启动后才会确定使用到的类, 反射机制为 Java 带来了灵活性, 避免将程序写死到代码中
反射的基本原理就是在运行期间通过 [[Java Virtual Machine]] 获取到这个类的 `.class` 文件 , 从而获得这个类的全部信息并可以对其操作

## 23. 什么是 java 序列化，如何实现 java 序列化？
Java 序列化就是将 Java 对象写出文件持久化到硬盘中的过程, 在 Java 中可以通过类实现 `Serializable` 接口的并指定版本号的形式来实现序列化.

# Java 高级

## 1. JVM 内存分哪几个区，每个区的作用是什么?
1. 方法区 (元空间): 用于存放类的原始模板消息, 元空间是一个共享区域
2. 堆: 用于存放对象实例和数组, GC 主要工作区域, 内部又分为新生代与老年代
3. 本地方法栈: 用于存放 Java 程序中 `native` 关键字修饰的方法
4. Java 方法栈: 分配给每个线程运行时的内存, 主要存储本地变量, 记录入栈/出栈及栈帧数据; 它是线程私有的
5. PC 寄存器: 每个线程私有的一个程序计数器, 用于记录代码行号, 指向即将执行的代码 [[Java Virtual Machine#PC 寄存器]]

## 2. Java 中垃圾收集的方法有哪些?
1. 标记清除算法: 从 GC Roots 根节点开始遍历, 将这个节点引用到的对象添加标记, 再遍历结束后, 没有被标记的对象都为不可达对象, 可以被回收 (回收空间碎片化)
2. 标记整理算法: 在标记清除方法的基础上, 将引用到的对象整理到内存的一边后, 清除所有边界外的空间
3. 复制算法: 将内存空间分为两份, 清理前将存活的对象复制到两份空间中的另一个区, 将这个区域的对象全部清除
4. 分代收集算法: 针对不同作用的分区, 采用不同的算法进行回收, hotSpot 就是采用这种算法

## 3. 如何判断一个对象是否存活? (或者 GC 对象的判定方法)
1. 引用计数法: 给对象添加一个计数器, 每次被引用时计数器+1 释放对象时-1, 当某个对象计数为 0 时即代表可以回收 (会产生循环引用导致无法回收对象) [[Java Virtual Machine#引用计数法]]
2. 可达性分析法: 使用一些被称为 GC Roots 的根节点作为起点, 依次遍历他们所引用的对象, 将被引用的对象添加标记. 当一个对象没有标记则证明未被引用, 可以回收 [[Java Virtual Machine#可达性分析算法]]

## 4. 什么情况下会产生 StackOverflowError（栈溢出）和 OutOfMemoryError（堆溢出）？怎么排查？
1. 在递归调用, 没有设置停止条件或者条件设置不合理, 出现栈溢出
2. 在使用 apache 旗下的 Excel 操作类 poi 时, 如果报表数据过大就会产生堆溢出 [[EasyExcel#概述]]或者查询数据库时的 `findAll()` 方法, 一次性将所有数据加载到堆内存, 可能引发堆溢出故障
3. 通过导出 dump 文件, 使用 MAT 工具的方式对可能的内存泄漏进行分析 [[Java Virtual Machine#定位分析堆 OOM 问题]]

## 5. 什么是线程池，线程池有哪些（创建）？
线程池是用于存放线程资源的容器, 线程并非一次性的资源, 通过线程池可以对线程资源完成复用. 在需要使用到多线程时直接从线程池中获取, 避免重复创建及销毁线程, 提高程序的响应速度. 通过线程池也能做到对线程的统一管理
线程池的创建方式有:
1. 通过 `Executors` 工具类的静态方法来创建线程池
2. 使用 `ThreadPoolExecutor` 类创建线程池

## 6. 为什么要使用线程池
1. 线程是一种昂贵的资源, 它的创建及销毁都要付出高昂的代价, 为了避免频繁的创建及销毁, 产生了线程池技术
2. 通过线程池可以对已经创建的线程资源进行复用, 避免系统重复创建及销毁线程, 拖慢响应速度
3. 通过线程池可以对一个系统中的线程资源做到统一维护和管理, 需要使用多线程时直接从线程池中获取

## 7. 线程池底层工作原理
[[day03_线程池与volatile#线程池工作原理]]

## 8. ThreadPoolExecutor 对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？

ThreadPoolExecutor 有七大核心参数, 他们分别是:
1. 常驻核心线程数 `corePoolSize`
2. 最大执行线程数 `maximumPoolSize`
3. 空闲线程存活时间 (非常驻核心线程) `KeepAliveTime`
4. 空闲线程存活时间单位 `TimeUnit`
5. 线程池工厂 `ThreadPoolFactory` 指定创建线程时使用的线程工厂
6. 任务队列 `ArrayBlockingQueue`, 存放等待分配线程执行的任务
7. 拒绝策略 `RejectedExecutionHandler`, 任务饱和后的拒绝策略
8. [[day03_线程池与volatile#创建线程池的七大核心参数]]

通常情况下, 建议核心线程数与最大执行线程数的数量保持一致, 避免系统运行中的线程创建于关闭, 保证系统的最快响应 [[day03_线程池与volatile#如何合理设置线程最大线程数和核心线程数?]]

拒绝策略有:
1. `AbortPolicy` 拒绝执行策略: 抛出 `rejectExecutException ` 异常, 拒绝执行
2. `DiscardPolicy` 丢弃任务策略: 默默丢弃无法处理的任务, 不抛出异常
3. `DiscardOldestPolicy` 丢弃任务队列中等待最久的任务, 并执行新任务
4. `CallrunsPolicy` 让调用者所属线程处理该任务

## 9. 常见线程安全的并发容器有哪些？
1. `ConcurrentHashMap`
2. `CopyOnWriteArrayList`
3. `CopyOnWriteSet`

## 10. Atomic 原子类了解多少？原理是什么？
[[day02_JUC辅助工具类#Atomic 原子类]]

## 11. Synchronized 底层实现是什么？Lock 底层是什么？有什么区别？
[[多线程#Lock 和 synchronized 的区别]]

## 12. 了解 ConcurrentHashMap 吗? 为什么性能比 HashTable 高，说下原理
ConcurrentHashMap 是保证线程安全的 HashMap 并发容器类

## 13. ConcurrentHashMap 的 put 流程

## 14. 了解 volatile 关键字不？

## 15. Synchronized 和 volatile 有什么区别？

## 16. Java 类加载过程?

## 17. 什么是类加载器，类加载器有哪些?

## 18. 简述 java 内存分配与回收策略以及 Minor GC 和 Major GC（full GC）

## 19. 如果查看死锁

## 20. Java 死锁如何避免

# MySQL 数据库
## 1. SQL 的 select 语句完整的执行顺序

## 2. MySQL 的事务

## 3. 简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别

## 4. 悲观锁和乐观锁的怎么实现？

## 5. 你们公司有哪些数据库设计规范？

## 6. 有没有设计过数据表? 你是如何设计的?

## 7. 聚簇索引与非聚簇索引有什么区别

## 8. 索引的底层实现是什么？什么情况下会索引失效？

## 9. B+tree 与 B-tree 区别

## 10. 以 MySQL 为例 Linux 下如何排查问题?

## 11. 如何处理慢查询

## 12. 数据库分表操作

## 13. MySQL 优化

## 14. SQL 语句优化案例

## 15. 常见面试 SQL



# Java Web
## 1. Http 常见的状态码有哪些？

## 2. GET 和 POST 的区别？

## 3. Cookie 和 Session 的区别


# Java 框架
## 1. 简单的谈一下 SpringMVC 的工作流程？

## 2. 说出 Spring 或者 SpringMVC 中常用的 5 个注解，并解释含义

## 3. 简述 SpringMVC 中如何返回 JSON 数据

## 4. 谈谈你对 Spring 的理解

## 5. Spring 中常用的设计模式

## 6. Spring 循环依赖问题
### 6.1 请解释一下 spring 中的三级缓存
### 6.2 三级缓存分别是什么? 三个 Map 有什么异同?
### 6.3 什么是循环依赖? 请你谈谈? 看过 spring 源码吗?
### 6.4 如何检测是否存在循环依赖? 实际开发中见过循环依赖的异常吗?
### 6.5 多例的情况下, 循环依赖问题为什么无法解决?

## 7. 介绍一下 Spring bean 的生命周期、注入方式和作用域

## 8. 请描述一下 Spring 的事务管理

## 9. MyBatis 中 #{}和${}的区别是什么？

## 10. Mybatis 中一级缓存与二级缓存？

## 11. MyBatis 如何获取自动生成的 (主) 键值?

## 12. 简述 Mybatis 的动态 SQL，列出常用的 6 个标签及作用

## 13. Mybatis 如何完成 MySQL 的批量操作, 举例说明

## 14. 谈谈怎么理解 SpringBoot 框架？

## 15. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？

## 16. Spring Boot 自动配置原理是什么？

## 17. SpringBoot 配置文件有哪些？怎么实现多环境配置？

## 18. SpringBoot 和 SpringCloud 是什么关系

## 19. SpringCloud 都用过哪些组件？介绍一下作用

## 20. Nacos 作用以及注册中心的原理

## 21. Feign 工作原理


# Redis 数据库
## 1. 介绍下 Redis？Redis 有哪些数据类型？

## 2. Redis 提供了哪几种持久化方式？

## 3. Redis 为什么快？

## 4. Redis 为什么是单线程的?

## 5. Redis 服务器的的内存是多大?

## 6. 为什么 Redis 的操作是原子性的，怎么保证原子性的？

## 7. Redis 有事务吗？

## 8. 使用 Redis 作为缓存，Redis 数据和 MySQL 数据库的一致性如何实现？

## 9. 缓存击穿，缓存穿透，缓存雪崩的原因和解决方案？(或者说使用缓存的过程中有没有遇到什么问题，怎么解决的）

## 10. 哨兵模式是什么样的？

## 11. Redis 常见性能问题和解决方案？

## 12. MySQL 里有大量数据，如何保证 Redis 中的数据都是热点数据？Redis 内存淘汰策略

## 13. Redis 集群方案应该怎么做？都有哪些方案？