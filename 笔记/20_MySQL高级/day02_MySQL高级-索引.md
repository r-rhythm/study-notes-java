# 什么是 MySQL 索引
- 索引的本质就是帮助 MySQL 高效获取数据的==数据结构==
- 索引存储于文件系统中
- 建立索引的目的就是**减少磁盘 I/O 次数, 提高查询效率**
- 和表结构一同存储在 \*. Ibd 文件中

# 创建索引的方式
1.  `CREATE INDEX indexName ON tableName(columName)` 
2. `ALTER TABLE tableName ADD INDEX indexName(columName)`
3. 创建表时, 在字段内部添加 `INDEX[indexName](columName)`


# 索引结构
- **B+ Tree, 最常见的索引类型, 大部分存储引擎都支持** 
- Hash 索引, 采用 Hash 表数据结构实现, 效率最高但无法做范围查询, 只能精确查询

# 索引数据结构推演
## 二叉树
- 每个节点最多有两个子节点
- 缺点: 节点数据没有大小限制, 不进行排序, 无法作为索引
## 二叉搜索树 BinarySearchTree
- 在二叉树的基础上, 添加了排序规则
- 左子节点比当前节点小, 右子节点比当前节点大
- 如果子节点于当前节点一样大, 可以将该节点放在左子节点或右子节点
- 缺点: 如果数据按照顺序大小新增, 则会**退化为一个单项链表**, 不会自平衡
## 平衡树二叉
- 自动平衡左右高度差 (左旋/右旋)
- 要求左右节点高度差不大于 1
- 缺点: 随着数据量的增加, 树的高度也越来越高, 每个高度都对应了一次磁盘的 I/O, 它也**不适合范围内的快速查找 (范围查询需要遍历整个树)**

优化二叉平衡树思路
- 将树的高度降低 (一个节点包含多个子节点, 多叉树)
- 一个节点存储 N 多个元素

## B-Trees
- 树的阶: 一个节点所拥有的最大子节点个数
- 一个 N 阶的 B-Trees, 每个节点可以存储 N-1 个元素
- 当节点的键值**大于等于阶**, 树节点裂变
- 裂变规则: 中间元素向上裂变
- 缺点: 由于完整数据是由根节点 + 叶子节点共同构成, 将所有的元素的值都存储在了节点中, 查询范围数据必然会遍历一棵子树, 所有不适合范围内查询

## B+Trees
- 在 B-Tree 的基础上, 裂变时**裂变节点也将作为右子节点中的一个叶子节点**
- 裂变后的叶子节点由指针组成一个单向链表,
- 非叶子节点的所有数据都在叶子节点中保存
- 非叶子节点的数据都存放在它右子节点的第一位叶子节点

# MySQL 中的 B+Trees 索引结构
## 特性
- MySQL 的索引结构对 B+Trees 结构进行了优化, 叶子节点在 B+Trees 的基础上**增加了一个指向相邻叶的指针**, 使叶子节点从一个单向的链表变为一个双向链表, 使得范围查询更加容易
- 叶子节点间为双向链表, 每个叶子节点中的记录于记录间为单向链表
- B+Trees 只有叶子节点才会存放用户数据, 它的非叶节点只存储索引及指向下个磁盘块的地址指针

## 每个节点内所包含的信息
- Record_type: 当前节点的类型记录, 0 为普通记录, 2 为最小记录, 3 为最大记录, 1 为非叶子节点
- Next_record: 存储下一条记录的相对位置, 在叶子内组成一个单向链表

## B+Trees 为什么 I/O 次数少
- B+Trees 的非叶子节点不存储用户数据, 只存储目录记录, InnoDB 每个磁盘块 (每一页) 默认大小为 16kb
- 如果 B+Trees 只存在一层, 则最多只能存储 16 条记录
- 而如果 B+Trees 有两层, 假设每个指针与键值大约占用 10 个字节, 则第一层就可以存储 1600 个指针, 1600 * 16 = 25600 条记录
- 再者 B+Trees 有三层的情况下, 即可存储 1600 \* 1600 \* 16 = 40, 960, 000 条记录, 也就是说, B+Trees 只需要三层即可存储千万级别的数据
- B+树相较于 B 树每个节点可以存储更多的记录, 树的高度就会更加的矮胖, IO 的次数也就会减小

# 索引回表
- 聚簇索引: 通过主键 id 建立的索引. 叶子节点存储索引及对应的一整行数据, 找到了索引也就找到了数据. 
- 非聚簇索引 (二级索引): 通过普通列创建的索引, 索引列于其他列的数据分开存储, *针对于频繁增加或删除列的情况???* #GOTO
- 当 SQL 去查询一个普通列的索引 (二级索引) 得不到想要的数据, 不得不再次根据 ID 查询聚簇索引, 这种现象称为回表
- 只查询某个索引结构中有的数据, 即可减少索引回表

聚簇索引与非聚簇索引的优缺点:
1. 聚簇索引将索引列与表中其他列的数据存储在一起, 所以通过聚簇索引可以非常快速的访问表中数据. 然而, 在需要在表中增加或删除一行, 会导致整个索引树的结构发生变化, 带来一些额外的开销
2. 非聚簇索引将索引列上的数据与其他列的数据分开存储在不同的物理位置上, 所以对表中增加或删除一行不会对整个表造成影响
3. 总的来说, 聚簇索引适用于查询速度很重要的情况, 而非聚簇索引更适用于需要更新数据的情况


# 索引覆盖
![[Pasted image 20221109144727.png]]
- 如上图所示, 如果查询 `SELECT id,name from table where name = ?` 则没有回表问题, 要查询的结果 id, name 都可以从二级索引中取到, 就称为索引覆盖
- 如果查询 `SELECT * FROM table WHERE name = ?` 则无法通过二级索引获得想要的数据, 会再次通过 id 查询聚簇索引, 产生回表问题 

# 索引优化

## 性能分析 (Explain)
EXPLAIN 关键字可以模拟 SQL 优化器执行 SQL 语句, 从而知道 MySQL 是如何执行 SQL 语句的
使用 `EXPLAIN + SQL` 可以查询 SQL 执行计划

## 执行计划各个字段解释
- **type** 表示 MySQL 决定如何查找表中的行
	- 性能从好到坏依次是 `system -> const  -> eq_ref -> ref -> range -> index -> all` 性能优化的目标, 至少达到 range 级别
	- All 全表扫描, 遍历全表找到对应的行
	- Index 全索引扫描, 只需要查询一个索引即可得到目标数据, 但没有设置范围, 需要扫描整个索引 B+树时
	- Range 在索引结构 index 的基础上, 增加范围查询 `BETWEEN AND > <` 等条件
	- Ref 通过普通二级索引列与常量进行等值匹配时 
	- Eq_ref 连接查询时通过主键或不允许为 NULL 的唯一二级索引列进行等值匹配时达到
	- Const 根据主键或唯一二级索引列与常量进行等值匹配时
	- System 只有在 MyISAM 搜索引擎下且表中只有一条记录时达到
- **possible_key** 表示执行时可能用到的索引 (多个)
- **key** 实际查询所用到的索引字段
- **key_length** 表示 MySQL 在索引内使用到的字节数, 可以根据这个数来判断是否充分利用了索引, 这个值的计算方式[参阅](https://www.modb.pro/db/52861), 通常情况来讲, 这个值越大越好
- Rows 表示 MySQL 检索出目标结果所需要检查行数的**预估值**
- Extra (额外的) 表示不适合在其他列显示但非常重要的补充信息
	- Using index
	- Using filesort, 排序操作无法使用到索引, 只能在内存或磁盘中进行排序, 无法利用索引完成的排序称为**文件排序**
	- Useing index condition, 使用**索引下推**(Index Condition Pushdown Optimization), 在联合索引中, 即使使用条件查询时某个字段是以 % 模糊查询等开头的情况导致某个索引字段失效的情况下, 存储引擎还是会使用这个字段来为我们进行一次数据的过滤, 尽可能的缩小回表范围