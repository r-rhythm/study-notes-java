# 索引失效的情况

## 全值匹配我最爱
## 带头大哥不能死, 中间小弟不能断

## 最佳左前缀法则
索引文件具有 B-Tree 的最左前缀匹配特性, 如果左边的值未确定, 则无法使用此索引
只要左边的匹配, 匹配几个字段就使用几个字段进行匹配
## 计算/函数/类型转换导致索引失效
- 索引保存的时字段的原始值, 而不是函数计算后的值, 所以计算或使用函数后自然无法使用索引
- 在表中字段类型与 where 条件对比的类型不一致时, MySQL 会使用 CSAT () 函数来进行类型的转换, 只要使用了函数, 就会导致索引失效
## 范围条件右侧的列索引失效
- 在出现 BETWEEN > < 等范围条件时, 会直接导致联合索引这个字段右边的索引失效
- **在创建联合索引时, 务必将确定值的字段放左边 (涉及范围查询的字段放到最后)**
- 在实际开发中, 范围查询 (如日期/金额等) 都应该放置在 where 条件的最右边
## 不等于判断
- 使用不等于作为条件, 即使使用了索引页必须逐个遍历以此来判断是否不等, 在优化器看来还不如直接走全盘扫描
## Is null 和 is not null
- Is null 就相当于等于某个值
- Is not null 相对不等于某个值
- 在实际开发中, 应该在设计表时就将字段设置 not null 非空约束, 使用某个特定的值来表示空, 如 int 类型的 0, 或 var 类型的 '' 空串等
- 同理, not like 也无法使用
## 通配符 % 开头
- 索引的第一个字段就无法确定会导致无法通过 B+ 树来判断目标结果的具体位置, 会全盘扫描依次对比
- *Java 开发手册* 强制页面搜索禁止使用做模糊或全模糊
## OR 前后存在非索引的列
- 即使左右任意一个条件走了索引, 没有索引的列还是要走一遍全盘扫描, 还不如直接全盘扫描一遍
## 数据库与表的字符集统一使用 utf-8mb4
- 如果表或库之间没有使用统一的字符集编码, 在联合查询时一定会先进行转码操作, 它会调用一个隐式的函数, 而函数一定会导致索引失效

# 创建索引的几点建议
1. 根据字段的内容过滤性来确定建立索引字段的优先级 (优先使用过滤性好的字段, 过滤性好的字段优先放在左边)
2. 当某个字段可能出现范围查询时, 尽可能的把它的次序放到后面

# 优化查询
## 左外连接
- **小表驱动大表** , 使用小表驱动, 表连接的可以减少表连接的次数, 提高性能
- 在**被驱动表 (大表) 的关联字段上建立索引**以进一步提升效率
## 内连接
- 在都有 (或都没有) 索引的情况下, SQL 优化器会**自动选择数据量小的表作为驱动表**
- 只有一方有索引的情况下, 就使用有索引的一方作为被驱动表
## 连接查询总结
- 尽可能使用单表 + 索引解决
- 单表无法满足需求的, 尽量考虑使用内连接, 在内连接中被驱动表关联字段建立索引
## 排序优化
- 目的: 去掉 Extra 中的 using filesort（手工排序）
- 当**范围条件** 和 Group by 或者 Order by (二选一) 同时出现时, 优先观察范围条件过滤数量, 如果过滤掉的数据足够多而需要排序的数据并不多时, 优先将索引建立在范围条件上, 反之亦然

# 慢查询日志
## 概述
使用慢日志可以记录哪些 SQL 超过了我们约定的最大容忍耗时上限
1. 热门接口开启 MySQL 慢查询日志, 设置耗时上限
2. 压力测试, 模拟并发访问热点接口
3. 查询慢查询日志, 即可找到超出耗时预期的 SQL 
4. 使用 Explain 对 SQL 进行针对性优化
## 设置慢查询日志
-  开启  `SET GLOBAL slow_query_log=1; `
- 查看启用状态与文件保存位置 `SHOW VARIABLES LIKE '%slow_query_log%'; `
- 查看最大容忍耗时上限 `SHOW VARIABLES LIKE '%long_query_time%'; -- 查看值：默认10秒`
- 修改上限 `SET GLOBAL long_query_time=0.1;`
- 修改后, 需要重新登录后生效

# 视图 View
- 虚拟存在的表, 可以对外隐藏一些基表的核心或敏感字段, 安全
- 它不存储数据, 数据的增删改操作都直接作用于基表之上
- 将一些复杂的可复用的查询语句封装为视图, 使得 SQL 语法更加清晰简洁
- 简而言之, MySQL 视图就是将一段常用或者复杂的 SQL 语句封装起来, 并给它取一个别名, 直接调用视图即可执行 SQL
```SQL
# 创建视图
CREATE VIEW <视图名> AS <SELECT语句>(不带 WHERE 条件的);

# 使用视图
SELECT * FROM view_name WHERE column = ?;
```
