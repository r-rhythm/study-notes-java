# 简介
## 概述
设计模式(design pattern)是前人对对软件工程中普遍存在,反复出现的问题所提出的解决方案和经验总结

## 学习设计模式的目的
1. 提高代码的复用性(相同功能的代码,不用多次编写)
2. 提高可读性(编程的规范性,便于其他的人员阅读理解)
3. 可扩展性(需要增加新的功能时更加方便)
4. 可靠性高(添加新功能后,不会对原先存在的功能造成影响)
5. 懂了设计模式,你才真正的懂了面向对象编程思想
## 学习设计模式学些什么?
学习设计模式就是学习用什么设计模式来解决什么样的问题
# 设计模式的七大原则
1. 单一职责
2. 接口隔离
3. 依赖倒置
4. 里氏替换
5. 开闭原则 OCP
6. 迪米特
7. 合成复用

设计模式原则是设计模式的基础,也是程序员在编码时应遵守的原则

## 单一职责原则
single responsibility,对类来说,一个类应该只负责一项职责(一个职责的修改不应该影响其他职责)严格遵守单一职责原则

方案:
1. 最简单的方式就是根据职责的不同,新建不同的类即可(系统开销较大,需要对原有的类做较大的修改)
2. 第二种:在原先的类中增加不同的方法,调用不同的方法实现不同的职责(在类级别上没有遵守单一职责原则,但在方法上遵守了),称为**单一职责下沉**(只有在方法数量足够少 & 逻辑足够简单时使用)

## 接口隔离原则
客户端不应该依赖它不需要的接口,如果接口中存在不需要使用的方法,就应该将接口拆分开

一个类通过接口的方式去依赖另一个类(接口指向实现类),如果这个接口中存在很多方法都是不需要使用到的,就可以将接口拆分开来,只需要与他们需要的接口建立连接即可

## 依赖倒转原则
1. 高层的模块不应该依赖低层的模块,二者都应该抽象
2. **抽象不应该依赖细节,细节应该依赖抽象**
3. 中心思想就是面向接口编程
4. 以抽象为基础搭建的架构比以细节为基础的架构更加稳定可靠
5. 使用**接口或者抽象类制定规范**,细节实现交给实现类去完成

依赖倒转的方式
1. 基于接口传递的方法实现依赖(使用接口作为形参)
2. 通过有参构造的方式来实现依赖传递
3. 通过 setter 方法来实现依赖传递

注意事项和细节
1. 尽量让低层的模块都有抽象类或者接口,或者两者都有,这样能使程序的稳定性更佳
2. 在**声明变量时,尽量使用抽象类或者接口**,提供一个缓冲层避免强引用,能够利于程序的扩展和优化
3. 继承时遵循里氏替换原则

## 里氏替换原则
里氏替换原则与继承体系密不可分,它提供了正确的使用继承体系的思路,使其为我们提高开发效率,而不是带来混乱

基本要求:
1. 在一个程序中**所有引用了基类的地方必须能够透明的使用它的其他子类对象**(使用基类或子类对于这个程序的结果不会发生任何行为改变)
2. 要实现透明的使用子类对象,在子类中就需要尽可能的**不去重写父类的方法**(如果需要对不同的方法做出不同解释的,应该再次将类进行抽象,实现不同逻辑的类作为同级别的存在而不是继承)
3. 在适当的情况下,可以通过聚合,组合(将需要使用到的类作为本类的属性,定义对外暴露的方法,内部使用这个属性类来做处理),依赖来解决问题,而不是重写

关于继承体系的补充:
1. 在继承的体系中,凡是父类已经实现好的方法实际上就是制定了一种规范和契约,虽然它不强制要求所有的子类都遵循这些契约,但如果子类对父类已经实现的方法进行任意的重写实质上会对整个继承体系造成破坏 [参阅:为什么说子类重写父类的方法是不符合逻辑的?](https://cubox.pro/my/highlight?id=ff80808184acf0460184b9995404592c)
2. 继承体系在提供了便利的同时,也带来了弊端.例如如果有多个子类依赖了 b,如果我们想对 b 进行修改时,就必须考虑到所有的子类,否则对他的修改就会导致故障.这使得程序的可移植性降低的同时增加了对象间的耦合性
3. 在开发中,继承体系应该严格的遵守里氏替换原则

## 开闭原则OCP※
基本介绍
1. 它是编程中最基本的,最重要的设计原则.遵循其他的原则及使用设计模式的目的就是为了遵循开闭原则
2. 实现在对程序进行功能扩展时,只对提供方的扩展开放,并对使用方的修改关闭(不修改对外暴露的接口?)
3. 当这个程序中出现功能的变化时,**通过扩展程序实体的行为来实现变化,而不是去修改原有的代码**

## 迪米特法则
基本介绍
1. 又称最少知道原则,一个类对自己依赖的类知道的越少越好
2. **被依赖的类不管有多复杂,都将逻辑全部封装在内部,除对外提供 public 方法外不暴露任何信息**
3. 迪米特法则还有个更简单的定义,即只与直接朋友通信(直接朋友值得是对象内出现的成员变量/方法参数/返回值中的类,而出现在局部变量中的类为陌生的类,即一个类类最好不要以局部变量的方式出现在另一个类的内部)
4. 迪米特法则的核心是减类之间不必要的耦合

## 合成复用原则
基本介绍
1. 尽量**使用合成/聚合的方式,而不是使用继承**
2. 如果只是希望一个类能够使用另一个类的方法,直接选择继承显然是缺乏考虑的

聚合: a 类中有一个成员变量 b 类,通过 setter 方法传入
组合: a 类中一个成员变量 b 类,在 a 类初始化时就将这个 b 类也一同初始化,称为组合 `B b = new b()`

# [[UML 类图]]


# Index
- [[设计模式-代理模式]]
- [[设计模式-单例(Singleton Pattern)]]
- [[设计模式-工厂模式]]
- [[设计模式-状态模式]]
- [[设计模式-工厂模式]]
- [[设计模式-模板模式]]
- [[设计模式-责任链模式]]