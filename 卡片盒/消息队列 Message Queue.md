# 什么是消息队列

> [!info] 
> - 它是一种进程间或同一进程不同线程间的通信方式
> - 可以简单的理解为生产者把要传输的数据存放在消息队列 (*消息中间件*) 中, 消费者从队列中获取数据. 不再直接接触

# 消息队列的主要作用

1. 异步操作：**优先处理需要即时响应的操作**, 将无需即时响应的非核心的业务提取出来异步处理, 降低系统响应时间
2. 应用解耦: 通过 MQ 连接不同的业务模块, 避免模块间的相互调用, 降低应用的[[耦合度 Coupling]] 程度
3. 流量削峰

> [!info] 流量削峰 (*削峰填谷*)
> * 在高并发的场景下, 会瞬间涌入大量的请求, 这些请求是服务器无法承载的, 如果这些请求直接发送到服务器会导致整个服务器的崩溃
> * 通过消息中间件 (RabbitMQ) 作为缓冲, 先将接收到到的请求暂存在消息队列中, 再由后台服务器每次从消息队列中获取一定数量的请求并做处理, 保证后台服务运转正常

> [!tip]
> 通俗的讲, 这里使用的中间件类似于大坝的作用, 拦蓄上游的洪水, 削减下游的峰值流量, 以达到减少灾害的作用


# 常见的 MQ 产品

- [[卡片盒/RabbitMQ]] 
- [[RocketMQ]] - Alibaba 信息堆积量大的系统采用
- Kafka - Apache 信息吞吐量大的系统采用
- ActiveMQ - Apache 老项目采用

# 术语

- **QPS**(*Queries Per Second*): 每秒处理请求的数量, 阈值 (临界值
- PV (*Page view*): 页面浏览量
- UV (*Unique Visitor*): 独立访客，统计 1 天内访问某站点的用户数。


# 死信队列

*如果确定了某个消息为死信, 为了能让这个死信还能被消费, 就需要把他存放到另一个队列中, 这个队列叫死信队列*

DeadLetter Exchange (死信交换机)*

> [!note] 死信
> 无法被消费的消息称之为死信
> 
> 产生死信有以下几种原因
> 1. 队列长度限制, 当队列内的信息长度达到限制后, 根据先进先出的原则, 最早进入队列的消息成为死信
> 2. 消费者拒绝签收且不将消息放回队列, 消息成为死信 (*不合理*) channel. BasicNack (deliveryTag, true, false)
> 3. 到达有效时间后未被消费 (TTL), 消息成为死信



# 消息幂等性保障
>[!warning]
>**保证同一个消息即使被发送多次, 最终也只能被消费一次**
使用**[[乐观锁]]**的思想来保证同一个消息就算发送多次, 最终只能消费一次

幂等性:  对于用户的同一操作, 不论发起多次请求还是一次请求结果都是一致的, 不会因为多次点击而产生副作用

具体实现:
- 使用 [[Redis]] 中的 `setnx()` 指令, 来确保这个消息以前是没有被消费过的. 它的思想类似于[[分布式锁#使用 Redis 实现分布式锁]], 都是使用排他的操作来保证唯一性
- 使用特殊前缀+消息作为 key, 0 或 1 作为 value 存入 redis 中
- 消费者接收到消息后, 存入 key 与 0 表示接收到消息
- 当消费者消费这个信息后, 将这个 key 的值从 0 改为 1, 表示已经消费完毕


# 消息百分百成功投递
1. 生产者发送消息之前定义业务表与消息表
	1. 业务表: 存放业务的数据 (减库存等等...)
	2. 消息表: 存放消息发送的状态 (0 为消息未发送, 1 成功发送等...)
2. 发送消息给 mq
3. Mq 根据[[RabbitMQ#消息的可靠性投递 (消息不丢失)|可靠性传递原则]]返回信息是否成功
4. 如果 mq 返回接收消息成功, 将信息状态表的状态设置为 1 发送成功
5. 为了解决特殊情况导致的信息未更新,**使用定时任务每隔 n 秒从消息表中获取状态是 0 的信息, 将状态为 0 的信息进行重新发送**, 在这个过程中要**保证同一个消息就算发送多次, 最终只能消费一次**
6. 约定同一个信息, 如果发送超过一个约定的次数后还失败, 就不再进行重新发送, 通过人工处理


# MQ 消息积压
1. 先修复 consumer 的问题, 确保他的正常消费速度, 然后将现有的 consumer 都停掉
2. 临时建立原先 10~20 倍的 queue (新建一个 topic，partition 是原来的 10 倍)
3. 写一个临时分发消息的 consumer, 替代掉先前直故障的 consumer, 用这个 consumer 来将队列中的消息分发到临时新建的 queue 中 (*由之前的直接操作数据库变为转发信息至临时的 queue 中*)
4. 扩充 10 倍的机器来部署 consumer, 让 consumer 来处理临时 queue 的信息
5. 快速将积压的信息恢复完毕后, 恢复到原来的部署架构







 