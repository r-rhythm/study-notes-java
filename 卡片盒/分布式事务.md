
> [!info] 什么是分布式事务
> - 分布式事务操作的是不同的数据库
> - 分布式事务就是为了保证**不同的数据库**数据保持一致
> - 分布式事务是指[[事务 Transaction]]的参与者,支持事务的服务器,事务管理器与资源服务器都分别部署在不同的服务器上
> - 每一次大的操作都由数个小的服务分别完成,分布式事务要保证事务的一致性,要么全部成功,要么全部失败

# 分布式事务解决方案
1. XA 两阶段提交(低效率)
2. TCC 三段提交(2 段)
3. 本地消息表(MQ + Table)
4. 事务消息(RoketMQ)
5. Seata

# 基于 XA 协议的两阶段提交(2PC)

XA(通信)协议:主要定义了事务管理器 TM(Transactional Manager) 和局部资源管理器 RM(Resource Manager,控制分支事务) 之间的接口。

2PC(*Two phase Commit*) 两阶段提交方式有两种角色
1. 协调者
2. 参与者
二阶段分别指的是准备(投票)和提交两个阶段
- 第一阶段,执行 SQL 但不提交事务
- 第二阶段,由事务参与者向协调者上报 SQL 的执行结果,由协调者通知各个参与者发起事务整体提交或全部回滚

两个阶段
1. 投票阶段(*voting phase*) 参与者将操作的结果通知协调者
2. 提交阶段(*commit phase*) 收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；

缺陷
1. 强一致性,在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。
2. 协调者单点故障,一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。
3. 消息不一致问题,第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

# 代码补偿(TCC)
TCC(*Try-Confirm-Cancel*)
- Try 在业务层面做修改,例如数据库中新增**预留**资源的字段.如冻结金额,冻结库存等
- Confirm 确定提交,指的是真正的执行完毕后
- Cancel 撤销操作,如果业务中出现异常,将预留的资源释放
- [参阅]( https://www.bilibili.com/video/BV1rT4y117sw?share_source=copy_web&vd_source=72c657d3991cbdeed2ac16025d77b130)
保证事务的最终一致性,在规定的时间内返回结果就好,不用一直占用资源

# 本地消息表(异步确保)※
保证事务的最终一致性
将分布式事务拆分成本地事务进行处理,不同的事务间使用MQ通信
1. 根据业务实际情况设置两张表,业务表和消息表.在生成业务订单的时候向两张表内添加数据,消息表内用 0 表示未提交,1 表示已处理
2. 轮询消息表,将未发送的消息使用 MQ 进行发送
3. 库存系统根据获取到的 MQ 消息修改库存信息
4. 库存系统修改完毕后将信息表内的这条消息状态修改为 1

![[分布式事务-本地消息表流程图.png]]

可能出现的问题
1. 如果库存系统修改状态的过程中修改失败,会导致通过消息发送多次,要保证[[消息队列 Message Queue#消息幂等性保障]]
2. 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

他的流程流程有点类似于 [[消息队列 Message Queue#消息百分百成功投递]]

# MQ 事务消息
> 半消息 + 消息回查的过程称为事务消息

目前主流的 MQ 中只有 [[RocketMQ]] 支持事务消息
实现的思路
1. 在业务开始时会向MQ中投递一个"半消息(*half message*,订阅方只能接收不能消费的消息)",


# Seata
![[Seata]]
# 总结
1. 什么是分布式事务?
2. 分布式事务的解决方案
3. Seata的执行流程
4. Seata整合